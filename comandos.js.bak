const fs = require('fs');
const os = require('os');
const path = require('path');
const { downloadContentFromMessage } = require('@whiskeysockets/baileys');
const axios = require('axios');
const { exec } = require('child_process');
const yts = require('yt-search');
const { evaluate } = require('mathjs');
const { downloadMediaMessage } = require('@whiskeysockets/baileys');
const { contador, carregarContador, salvarContador, zerarContadorGrupo } = require('./utils/contador');

const CampoMinado = require('./dados/campominado.js');
const Damas = require('./dados/dama.js');
const JogodaVelha = require('./dados/jogodavelha.js');
const Xadrez = require('./dados/xadrez');
const { getWeeklyWeather } = require('./comandos/clima');


const agendamentosGrupo = require('./dados/agendamentos.json');
const { carregarConfigGrupo, salvarConfigGrupo } = require('./utils/grupoConfig');
const infoGp = require('./dados/infogp');

const vipPath = path.join(__dirname, './dados/vip.json');
let vipList = {};

const vipCmdPath = './dados/cmdvip.json';

// Carrega comandos VIP
let cmdVIP = {};
if (fs.existsSync(vipCmdPath)) {
  cmdVIP = JSON.parse(fs.readFileSync(vipCmdPath, 'utf-8'));
}

// âœ… Carregar as informaÃ§Ãµes do dono
const donoInfo = JSON.parse(fs.readFileSync('./dono/info.json', 'utf-8'));
const dono = donoInfo?.numerodono?.replace(/\D/g, '') + '@s.whatsapp.net';
let nomebot = donoInfo?.nomebot || 'Bot';
const muteBotUsers = new Set();
const spamBotMap = new Map();

// âœ… Comandos externos
const menuCommand = require('./comandos/menu.js');
const mutedPath = './dados/muted.json';
const menuAdmCommand = require('./comandos/menuadm.js');
const menuJogosCommand = require('./comandos/menuJogos.js');
const menuDonoCommand = require('./comandos/menudono.js');
const menuZoeiraCommand = require('./comandos/menuzoeira.js');
const menuRankCommand = require('./comandos/menurank.js');
const pathblock = './dados/bloqueados.json';
const { agendamentos, salvarAgendamentos } = require('./utils/agendamentos');
const { handleNamorar } = require('./comandos/namorar');

// **Carregue o contador assim que o bot iniciar**
carregarContador();
let mutedUsers = carregarMutados();
const floodBot = {};
const ignoradosBot = {};
const groupMetadataCache = {}; // cache simples
const { getMessageText } = require('./utils/mensagem');

const advFile = './dados/advertencias.json';
if (!fs.existsSync(advFile)) fs.writeFileSync(advFile, '{}');

    //   FUNÃ‡Ã•ES  //
function identificarAlvo(msg, sender) {
const citado = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0] ||
msg.message?.extendedTextMessage?.contextInfo?.participant ||
sender;
return citado;
}
function identificarAlvo(msg, sender) {
  const context = msg.message?.extendedTextMessage?.contextInfo || msg.message?.contextInfo || {};
  const mencionado = context.mentionedJid?.[0];
  const citado = context.participant;
  return typeof mencionado === 'string' ? mencionado :
         typeof citado === 'string' ? citado :
         sender;
}
function carregarMutados() {
  try {
    if (!fs.existsSync(mutedPath)) fs.writeFileSync(mutedPath, JSON.stringify({}));
    return JSON.parse(fs.readFileSync(mutedPath));
  } catch (err) {
    console.error('Erro ao carregar mutados:', err);
    return {};
  }
}

function salvarMutados(mutedUsers) {
  try {
    fs.writeFileSync(mutedPath, JSON.stringify(mutedUsers, null, 2));
  } catch (err) {
    console.error('Erro ao salvar mutados:', err);
  }
}

// FunÃ§Ã£o para salvar
function salvarAdvs(data) {
  fs.writeFileSync(advFile, JSON.stringify(data, null, 2));
}
  
function carregarBloqueados() {
  try {
    if (!fs.existsSync(pathblock)) {
      fs.writeFileSync(pathblock, JSON.stringify([]));
    }
    const dados = fs.readFileSync(pathblock, 'utf8');
    return JSON.parse(dados);
  } catch (e) {
    console.error('Erro ao carregar bloqueados:', e);
    return [];
  }
}
function salvarBloqueados(lista) {
  try {
    fs.writeFileSync(pathblock, JSON.stringify(lista, null, 2));
  } catch (e) {
    console.error('Erro ao salvar bloqueados:', e);
  }
}
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function saveCmdVIP() {
  fs.writeFileSync(vipCmdPath, JSON.stringify(cmdVIP, null, 2));
}
function reloadCmdVIP() {
  if (fs.existsSync(vipCmdPath)) {
    cmdVIP = JSON.parse(fs.readFileSync(vipCmdPath, 'utf-8'));
  }
}

function loadVIP() {
  if (fs.existsSync(vipPath)) {
    try {
      vipList = JSON.parse(fs.readFileSync(vipPath, 'utf-8'));
    } catch {
      vipList = {};
    }
  }
}
function saveVIP() {
  fs.writeFileSync(vipPath, JSON.stringify(vipList, null, 2));
}
function isVIP(jid) {
  const now = Date.now();
  if (vipList[jid] && vipList[jid].expira > now) {
    return true;
  } else {
    delete vipList[jid];
    saveVIP();
    return false;
  }
}
loadVIP();

// ============================== //
async function getSafeGroupMetadata(sock, jid) {
  try {
    if (!jid.endsWith('@g.us')) return null;
    return await sock.groupMetadata(jid);
  } catch (err) {
    console.error('Erro ao obter metadata do grupo:', err?.message || err);
    return null;
  }
}

async function getGroupMetadataCached(jid, sock) {
  if (groupMetadataCache[jid]) {
    return groupMetadataCache[jid];
  }

  const metadata = await getSafeGroupMetadata(sock, jid);
  if (metadata) groupMetadataCache[jid] = metadata;
  return metadata;
}

async function executarComandos(sock, msg, from, msgLower, isGroup, sender, pushName) {
  if (!msgLower) return;
  const grupoInfo = isGroup ? await sock.groupMetadata(from) : {};
  const senderId = msg.key.participant || msg.key.remoteJid;
  const isGroupAdmin = isGroup && grupoInfo?.participants?.some(p => p.id === senderId && p.admin);
  const text = msg.message?.conversation ||
               msg.message?.extendedTextMessage?.text ||
               msg.message?.imageMessage?.caption ||
               msg.message?.videoMessage?.caption ||
               '';               
const body = (msg.message?.conversation ||
              msg.message?.extendedTextMessage?.text ||
              msg.message?.imageMessage?.caption ||
              msg.message?.videoMessage?.caption ||
              msg.message?.documentMessage?.caption ||
              msg.message?.buttonsResponseMessage?.selectedButtonId ||
              msg.message?.listResponseMessage?.singleSelectReply?.selectedRowId ||
              '').trim();               

// ===================== MENUS =====================

// Menu principal
if (isGroup && msgLower === 'menu') {
    await sleep(700);  
    await menuCommand(msg, sock, from);
} 
// Menu administrativo
else if (isGroup && msgLower === 'menuadm') {
    await sleep(600);
    await menuAdmCommand(msg, sock, from);
}
// Menu do dono
else if (isGroup && msgLower === 'menudono') {
    await sleep(500);
    await menuDonoCommand(msg, sock, from);
}
// Menu zoeira
else if (msgLower === 'menuzoeira') {
    await menuZoeiraCommand(msg, sock, from);
}
// Menu jogos
else if (isGroup && msgLower === 'menujogos') {
    await sleep(500);
    await menuJogosCommand(msg, sock, from);
}
// Menu ranks
else if (isGroup && msgLower === 'menurank') {
    await sleep(500);
    await menuRankCommand(msg, sock, from);
}


// ===== CAMPO MINADO =====
else if (/^campominado\b/i.test(text)) {
    await CampoMinado.startChallenge(sock, msg, from, isGroup);
} 

// ===== DAMAS =====
else if (/^dama\b/i.test(text)) { // â¬…ï¸ Trigger para iniciar o Damas
    await Damas.startChallenge(sock, msg, from, isGroup);
} 
else if (/^(sim|s|nÃ£o|nao|n)$/i.test(text)) {
    // Verifica se existe partida de Damas aguardando
    if (Damas.games[from] && Damas.games[from].status === 'aguardando') {
        await Damas.acceptOrDecline(sock, msg, from, text.toLowerCase());
    }
} 
// Fazer jogada no Damas (ex: "A3 B4")
else if (/^[A-H][1-8]\s*[A-H][1-8]$/i.test(text)) {
    if (Damas.games[from] && Damas.games[from].status === 'jogando') {
        await Damas.makeMove(sock, msg, from, text.toUpperCase());
    }
}
// Resetar partida de Damas
else if (/^resetdama$/i.test(text)) {
    await Damas.resetGame(sock, msg, from);
}

// ===== XADREZ =====
else if (/^xadrez\b/i.test(text)) { // â¬…ï¸ Trigger para iniciar o Xadrez
    await Xadrez.startChallenge(sock, msg, from, isGroup);
} 
else if (/^(sim|s|nÃ£o|nao|n)$/i.test(text)) {
    // Primeiro verifica Campo Minado
    if (CampoMinado.games[from] && CampoMinado.games[from].status === 'aguardando') {
        await CampoMinado.acceptOrDecline(sock, msg, from, text.toLowerCase());
    }
    // Depois Jogo da Velha
    else if (JogodaVelha.games[from] && JogodaVelha.games[from].status === 'aguardando') {
        await JogodaVelha.acceptOrDecline(sock, msg, from, text.toLowerCase());
    }
    // Depois Xadrez
    else if (Xadrez.games[from] && Xadrez.games[from].status === 'aguardando') {
        await Xadrez.acceptOrDecline(sock, msg, from, text.toLowerCase());
    }
}

// Fazer jogada no Campo Minado
else if (/^[A-H][1-8]$/i.test(text)) {
    await CampoMinado.makeMove(sock, msg, from, text.toUpperCase());
} 
// Fazer jogada no Xadrez
else if (/^[A-H][1-8]\s*[A-H][1-8]$/i.test(text)) {
    await Xadrez.makeMove(sock, msg, from, text.toUpperCase());
} 
// ===== JOGO DA VELHA =====
else if (/^jogodavelha\b/i.test(text)) {
    await JogodaVelha.startChallenge(sock, msg, from, isGroup);
}
// Fazer jogada no Jogo da Velha (1-9 ou linha coluna)
else if (/^[1-9]$/.test(text) || /^[1-3]\s*[ ,;:-]?\s*[1-3]$/.test(text)) {
    await JogodaVelha.makeMove(sock, msg, from, text);
} 

else if (/^resetxadrez$/i.test(text)) {
    await Xadrez.resetGame(sock, msg, from);
}


// ===== CLIMA =====
else if (msgLower === 'clima') {
  const cidadePadrao = 'SÃ£o Paulo'; // vocÃª pode trocar ou puxar de config de grupo
  const previsao = await getWeeklyWeather(cidadePadrao, 7);
  await sock.sendMessage(from, { text: previsao }, { quoted: msg });
}

  else if (/^([#])?ping$/i.test(msgLower)) {
  await sleep(100);
    const { performance } = require('perf_hooks');
    try {
      await sock.sendMessage(from, {
        react: {
          text: 'âš¡',
          key: msg.key
        }
      });
      const startTime = performance.now();
      await sock.sendMessage(from, {
        text: '*â³ğ˜Šğ˜¢ğ˜­ğ˜¤ğ˜¶ğ˜­ğ˜¢ğ˜¯ğ˜¥ğ˜° ğ˜·ğ˜¦ğ˜­ğ˜°ğ˜¤ğ˜ªğ˜¥ğ˜¢ğ˜¥ğ˜¦...*',
        contextInfo: {
          externalAdReply: {
            title: 'ğ˜Šğ˜¢ğ˜­ğ˜¤ğ˜¶ğ˜­ğ˜¢ğ˜¯ğ˜¥ğ˜° ğ˜±ğ˜ªğ˜¯ğ˜¨...',
            body: 'â±ï¸ğ˜ˆğ˜¨ğ˜¶ğ˜¢ğ˜³ğ˜¥ğ˜¦',
            thumbnailUrl: 'https://files.catbox.moe/qnhouw.gif',
            sourceUrl: 'https://www.youtube.com/channel/UCF6dDTE8uON-PbWQz-xPIvA',
            mediaType: 1,
            renderLargerThumbnail: false,
            showAdAttribution: false
          }
        }
      });
      const endTime = performance.now();
      const velocidade = Math.floor(endTime - startTime);
      const used = process.memoryUsage().rss / 1024 / 1024;
      const totalRam = os.totalmem() / 1024 / 1024;
      const cpuInfo = os.cpus()?.[0]?.model || 'CpuQuÃ¢ntico';
      const uptimeSec = Math.floor(process.uptime());
      const uptimeHoras = Math.floor(uptimeSec / 3600);
      const uptimeMin = Math.floor((uptimeSec % 3600) / 60);
      const uptimeRest = uptimeSec % 60;
      const plataforma = os.platform();
      const arquitetura = os.arch();
      const thumbnailFinal = velocidade > 360
        ? ''
        : 'https://files.catbox.moe/3ei78v.jpg';
      const textoFinal =
        `*ğ˜ğ˜¦ğ˜­ğ˜°ğ˜¤ğ˜ªğ˜¥ğ˜¢ğ˜¥ğ˜¦ ğ˜®ğ˜¦ğ˜¥ğ˜ªğ˜¥ğ˜¢ ğ˜¦ğ˜® ${velocidade}ms!*\n` +
        `ğŸ§  *ğ˜Šğ˜—ğ˜œ:* ${cpuInfo}\n` +
        `ğŸ“Š *ğ˜™ğ˜ˆğ˜” ğ˜Œğ˜” ğ˜œğ˜šğ˜–:* ${used.toFixed(2)}MB\n` +
        `ğŸ“Š *ğ˜™ğ˜ˆğ˜” ğ˜›ğ˜–ğ˜›ğ˜ˆğ˜“:* ${totalRam.toFixed(2)}MB\n` +
        `ğŸ“± *ğ˜šğ˜ğ˜šğ˜›ğ˜Œğ˜”ğ˜ˆ:* ${plataforma} ${arquitetura}\n` +
        `ğŸ• *ğ˜›ğ˜”ğ˜— ğ˜–ğ˜•ğ˜“ğ˜ğ˜•ğ˜Œ:* ${uptimeHoras}h ${uptimeMin}m ${uptimeRest}s`;
      await sock.sendMessage(from, {
        text: textoFinal,
        contextInfo: {
          externalAdReply: {
            title: 'Ping concluÃ­do!',
            body: `âš¡ ${velocidade}ms`,
            thumbnailUrl: thumbnailFinal,
            sourceUrl: 'https://www.youtube.com/channel/UCF6dDTE8uON-PbWQz-xPIvA',
            mediaType: 1,
            renderLargerThumbnail: false,
            showAdAttribution: false
          }
        }
      });
    } catch (err) {
      await sock.sendMessage(from, { text: 'âŒ Erro ao medir ping.' }, { quoted: msg });
      console.error('Erro ao medir ping:', err);
    }
  }

else if (isGroup && msgLower.trim() === 'bot') {
  const senderId = msg.key.participant || msg.key.remoteJid;
  if (ignoradosBot?.[senderId] && Date.now() < ignoradosBot[senderId]) {
    return;
  }

  if (!floodBot[senderId]) floodBot[senderId] = [];
  floodBot[senderId].push(Date.now());
  floodBot[senderId] = floodBot[senderId].filter(ts => Date.now() - ts < 5000);

  if (floodBot[senderId].length >= 3) {
    ignoradosBot[senderId] = Date.now() + 10 * 60 * 1000;
    await sock.sendMessage(from, {
      text: 'ğŸ–ï¸ Ei, calma lÃ¡! TÃ¡ flodando meu sistema, criatura ğŸ˜ ',
    }, { quoted: msg });
    try {
      await sock.sendMessage(from, {
        sticker: fs.readFileSync('./dados/figurinhas/flodbot.webp')
      }, { quoted: msg });
    } catch (e) {
      console.error('Erro ao enviar sticker de flood:', e);
    }
    return;
  }

  const frasesBot = [
    '*ooie to aqui, linda e belağŸ§šğŸ»â€â™€ï¸*', //1
    '*fala comigo, bb an ?...* ğŸ˜š',  //2
    ';-;', //3
    '*me chamou, mozÃ£o cachorro do agrado rs?*', //4
    'posso nem descansar corno', //5
    '*Como possso te ajudar hoje ?* ğŸ™‚', //6
    'ğŸ‘ğŸ‘', //7 
    '*me trata com carinho, viu?* ğŸ’…', //8
    '*O mais lindo do grupo ta onâœ¨', //9
    '*tÃ´ de olho nesse grupo*ğŸ‘ï¸ğŸ‘ï¸', //10
    '*vc de novo criatura me ama so pode*',
    '*falar comigo Ã© perigoso, posso te viciar*ğŸ˜¹',
    '*aaaaaaaa*',
    'oque e fresco posso nem descansar mais',
    'bot Ã© tu, kkkkkkk'
  ];

  const figurinhasBot = [
    './dados/figurinhas/bot1.webp',
    './dados/figurinhas/bot2.webp',
    './dados/figurinhas/bot3.webp',
    './dados/figurinhas/bot4.webp',
    './dados/figurinhas/bot5.webp',
    './dados/figurinhas/bot6.webp',
    './dados/figurinhas/bot7.webp',
    './dados/figurinhas/bot8.webp',
    './dados/figurinhas/bot9.webp',
    './dados/figurinhas/bot10.webp',
    './dados/figurinhas/bot11.webp',
    './dados/figurinhas/bot12.webp',
    './dados/figurinhas/bot13.webp',
    './dados/figurinhas/bot14.webp',
    './dados/figurinhas/bot15.webp'
  ];

  const index = Math.floor(Math.random() * frasesBot.length);
  const fraseAleatoria = frasesBot[index];
  const figurinhaPath = figurinhasBot[index];

  await sock.sendMessage(from, {
    text: fraseAleatoria,
  }, { quoted: msg });

  try {
    await sock.sendMessage(from, {
      sticker: fs.readFileSync(figurinhaPath)
    }, { quoted: msg });
  } catch (e) {
    console.error(`Erro ao enviar figurinha ${figurinhaPath}:`, e);
    // jÃ¡ enviou o texto, entÃ£o sÃ³ loga
  }

  try {
    await sock.sendMessage(from, {
      react: { text: 'ğŸ’', key: msg.key }
    });
  } catch (e) {
    console.error('Erro ao reagir:', e);
  }
}

else if (msgLower.startsWith('nomebot ')) {
  if (!donoInfo || !donoInfo.numerodono) {
    await sock.sendMessage(from, {
      text: 'âŒ O nÃºmero do dono atual nÃ£o estÃ¡ configurado corretamente.'
    }, { quoted: msg });
    return;
  }
  const numeroDonoAtual = donoInfo.numerodono.replace(/\D/g, '');
  const senderRaw = msg.key.participant || msg.key.remoteJid || sender || '';
  const numeroSender = String(senderRaw).split('@')[0].replace(/\D/g, '');
  const numeroBot = (sock?.user?.id || '').split('@')[0].replace(/\D/g, '');
  const isDono = numeroSender === numeroDonoAtual;
  const isBot = msg.key.fromMe === true;
  if (!isDono && !isBot) {
    await sock.sendMessage(from, {
      text: 'âŒ Apenas o dono atual ou o prÃ³prio bot pode alterar o nome do bot.'
    }, { quoted: msg });
    return;
  }
  const novoNome = body.slice(body.indexOf(' ') + 1).trim(); // usa body pra manter maiÃºsculas
  if (!novoNome || novoNome.length < 3) {
    await sock.sendMessage(from, {
      text: 'âš ï¸ Use: nomebot NomeDoBot'
    }, { quoted: msg });
    return;
  }
  donoInfo.nomebot = novoNome;
  fs.writeFileSync('./dono/info.json', JSON.stringify(donoInfo, null, 2));
  if (typeof nomebot !== 'undefined') nomebot = novoNome;
  await sock.sendMessage(from, {
    text: `â˜‘ï¸Nome atualizado para:\nğŸ˜¸ *${novoNome}*`
  }, { quoted: msg });
}

   else if (isGroup && /^([#])?verlista\b/i.test(msgLower)) {
   await sleep(900);
    const grupoPath = `./dados/grupos/${from}.json`;
     if (!fs.existsSync(grupoPath)) return await sock.sendMessage(from, { text: 'âš ï¸     Nenhuma lista negra encontrada.', quoted: msg });
     const config = JSON.parse(fs.readFileSync(grupoPath));
     const lista = config.listanegra || [];
     if (lista.length === 0) return await sock.sendMessage(from, { text: 'âœ…Nenhum nÃºmero na lista negra.', quoted: msg });
     const numeros = lista.map(n => `@${n.split('@')[0]}`).join('\n');
    await sock.sendMessage(from, { text: `ğŸ›‘ *Lista Negra:*\n\n${numeros}`, mentions: lista }, { quoted: msg });
}

else if (isGroup && /^([#])?dono$/i.test(msgLower)) {
    await sock.sendMessage(from, {
      react: {
        text: 'ğŸ‘‘',
        key: msg.key
      }
    });  
  const getBuffer = async (url) => (await axios.get(url, { responseType: 'arraybuffer' })).data;
  const info = JSON.parse(fs.readFileSync('./dono/info.json', 'utf-8'));
  const nomeDono = info.nick || 'Dono';
  const numeroDono = info.numerodono || '559999999999';
  const nomeBot = info.nomebot || 'Bot';
  const thumbnail = await getBuffer('https://files.catbox.moe/aeakfl.jpg'); // miniatura
  const vcard = `
BEGIN:VCARD
VERSION:3.0
FN:${nomeDono}
ORG:${nomeBot};
TEL;type=CELL;type=VOICE;waid=${numeroDono}:+${numeroDono}
END:VCARD`.trim();
  await sock.sendMessage(from, {
    contacts: {
      displayName: nomeDono,
      contacts: [{ vcard }]
    },
    contextInfo: {
      externalAdReply: {
        title: `ğŸ‘‘ ğ——ğ—¼ğ—»ğ—¼ ğ—±ğ—¼ ${nomeBot}`,
        body: `ğ—–ğ—¼ğ—»ğ˜ğ—®ğ˜ğ—¼ ğ—±ğ—² ${nomeDono}`,
        mediaType: 1,
        renderLargerThumbnail: true,
        previewType: 0,
        thumbnail,
        sourceUrl: 'https://wa.me/qr/FVXHABQQZ4OIO1'
      }
    }
  }, { quoted: msg });
} 

else if (isGroup && msgLower.startsWith('tirardalista')) {
  await sleep(900);

  if (!isGroupAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
    return;
  }

  const grupoPath = `./dados/grupos/${from}.json`;
  if (!fs.existsSync(grupoPath)) {
    fs.writeFileSync(grupoPath, JSON.stringify({ listanegra: [] }, null, 2));
  }

  const configGrupo = JSON.parse(fs.readFileSync(grupoPath));
  if (!configGrupo.listanegra) configGrupo.listanegra = [];

  let alvo = null;

  const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0];
  const replyParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant;

  if (mentioned) {
    alvo = mentioned;
  } else if (replyParticipant) {
    alvo = replyParticipant;
  } else {
    // Coleta todos os dÃ­gitos do texto, mesmo separados
    const numeros = text.match(/\d+/g);
    if (numeros) {
      const numeroLimpo = numeros.join('');
      if (numeroLimpo.length >= 10 && numeroLimpo.length <= 15) {
        alvo = numeroLimpo + '@s.whatsapp.net';
      }
    }
  }

  if (!alvo) {
    await sock.sendMessage(from, {
      text: 'âŒ Marque um usuÃ¡rio, responda uma mensagem ou digite o nÃºmero para remover da lista negra.'
    }, { quoted: msg });
    return;
  }

  if (!configGrupo.listanegra.includes(alvo)) {
    await sock.sendMessage(from, {
      text: `âŒ O nÃºmero ${alvo.replace(/@s\.whatsapp\.net/, '')} nÃ£o estÃ¡ na lista negra.`
    }, { quoted: msg });
    return;
  }

  configGrupo.listanegra = configGrupo.listanegra.filter(n => n !== alvo);
  fs.writeFileSync(grupoPath, JSON.stringify(configGrupo, null, 2));

  await sock.sendMessage(from, {
    text: `âœ… O nÃºmero ${alvo.replace(/@s\.whatsapp\.net/, '')} foi removido da lista negra.`
  }, { quoted: msg });
}

else if (isGroup && msgLower.startsWith('listanegra')) {
  if (!isGroupAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
    return;
  }

  const groupId = from;
  const configPath = `./dados/grupos/${groupId}.json`;
  if (!fs.existsSync(configPath)) {
    fs.writeFileSync(configPath, JSON.stringify({ listanegra: [] }, null, 2));
  }
  const configGrupo = JSON.parse(fs.readFileSync(configPath));
  let alvo = null;

  const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0];
  const replyParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant;

  if (mentioned) {
    alvo = mentioned;
  } else if (replyParticipant) {
    alvo = replyParticipant;
  } else {
    // Junta tudo que for dÃ­gito do comando e forma o nÃºmero
    const numeros = text.match(/\d+/g);
    if (numeros) {
      const numeroLimpo = numeros.join(''); // Junta tudo: [55,79,9920,9607] => 557999209607
      if (numeroLimpo.length >= 10 && numeroLimpo.length <= 15) {
        alvo = numeroLimpo + '@s.whatsapp.net';
      }
    }
  }

  if (!alvo) {
    await sock.sendMessage(from, {
      text: 'âŒ Marque um usuÃ¡rio, responda uma mensagem ou digite o nÃºmero.'
    }, { quoted: msg });
    return;
  }

  if (!configGrupo.listanegra.includes(alvo)) {
    configGrupo.listanegra.push(alvo);
    fs.writeFileSync(configPath, JSON.stringify(configGrupo, null, 2));
    await sock.sendMessage(from, {
      text: `*UsuÃ¡rio adicionado Ã  lista negrağŸ’€:*\n\nâ€¢ ${alvo.replace(/@s\.whatsapp\.net/, '')}`
    }, { quoted: msg });
  } else {
    await sock.sendMessage(from, {
      text: `âš ï¸ Esse usuÃ¡rio jÃ¡ estÃ¡ na lista negra.`
    }, { quoted: msg });
  }
}

else if (msgLower.startsWith('perfil')) {
  await sleep(900);
  if (!isGroup) return;

  // LÃª dados do dono
  const infoDono = JSON.parse(fs.readFileSync('./dono/info.json', 'utf-8'));
  const numeroDono = infoDono.numerodono.replace(/\D/g, '');
  const senderRaw = msg.key.participant || msg.key.remoteJid || '';
  const senderNumero = String(senderRaw).split('@')[0].replace(/\D/g, '');
  const isDono = senderNumero === numeroDono;

  // LÃª lista VIP
  const vipPath = './dados/vip.json';
  let vipList = {};
  if (fs.existsSync(vipPath)) {
    vipList = JSON.parse(fs.readFileSync(vipPath, 'utf-8'));
  }

  const senderJid = msg.key.participant || msg.key.remoteJid || sender;
  const isVIP = Boolean(vipList[senderJid]);

  // Alvo mencionado
  const mentionedJid = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0];

  // Se marcou outra pessoa e nÃ£o Ã© dono nem VIP â†’ bloqueia
  if (mentionedJid && !isDono && !isVIP) {
    await sock.sendMessage(from, { text: 'ğŸš« Apenas o dono ou usuÃ¡rios VIP podem ver o perfil de outras pessoas.' }, { quoted: msg });
    return;
  }

  // Identifica alvo
  let rawAlvo = sender;
  if (mentionedJid && (isDono || isVIP)) rawAlvo = mentionedJid;
  else if (msg.key.participant) rawAlvo = msg.key.participant;
  else if (msg.key.remoteJid && msg.key.remoteJid.endsWith('@s.whatsapp.net')) rawAlvo = msg.key.remoteJid;

  const alvo = typeof rawAlvo === 'string' ? rawAlvo : String(rawAlvo);
  const userNumber = alvo?.replace(/[^0-9]/g, '') || '';
  if (!userNumber) {
    await sock.sendMessage(from, { text: 'âŒ UsuÃ¡rio invÃ¡lido ou nÃ£o identificado.' }, { quoted: msg });
    return;
  }
  const userId = userNumber + '@s.whatsapp.net';
  if (!userId || userId === 'null@s.whatsapp.net') {
    await sock.sendMessage(from, { text: 'âŒ NÃ£o foi possÃ­vel identificar o usuÃ¡rio corretamente.' }, { quoted: msg });
    return;
  }

  try {
    await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
  } catch (e) {
    console.error('Erro ao reagir Ã  mensagem:', e);
  }

  // Foto de perfil
  let ppUrl;
  try {
    ppUrl = await sock.profilePictureUrl(userId, 'image');
  } catch {
    ppUrl = 'https://files.catbox.moe/590tu5.jpg';
  }

  // Thumbnail
  let thumbnailBuffer;
  try {
    const res = await axios.get(ppUrl, { responseType: 'arraybuffer' });
    thumbnailBuffer = res.data;
  } catch (e) {
    console.error('Erro ao baixar thumbnail:', e);
    thumbnailBuffer = null;
  }

  // Verifica se Ã© admin
  let isAdminUser = false;
  try {
    const metadata = await sock.groupMetadata(from);
    const participant = metadata.participants.find(p => p.id === userId);
    isAdminUser = participant?.admin === 'admin' || participant?.admin === 'superadmin';
  } catch {}

  // Bio
  let bio = 'Sem bio';
  try {
    const statusUser = await sock.fetchStatus(userId);
    if (Array.isArray(statusUser) && statusUser.length > 0 && statusUser[0].status) {
      if (typeof statusUser[0].status === 'object' && statusUser[0].status.status) {
        bio = statusUser[0].status.status;
      } else if (typeof statusUser[0].status === 'string') {
        bio = statusUser[0].status;
      }
    }
  } catch (err) {
    console.error(`âŒ Erro ao buscar recado de ${userId}:`, err);
  }

  // Contador
  const grupoID = from;
  try {
    if (!contador[grupoID]) {
      const metadata = await sock.groupMetadata(grupoID);
      contador[grupoID] = { nome: metadata.subject || 'Grupo sem nome', usuarios: {} };
    }
    if (!contador[grupoID].usuarios[userId]) {
      contador[grupoID].usuarios[userId] = {};
    }
    const chaves = ['mensagens', 'figurinhas', 'audios', 'fotos', 'videos'];
    for (const chave of chaves) {
      if (contador[grupoID].usuarios[userId][chave] === undefined) {
        contador[grupoID].usuarios[userId][chave] = 0;
      }
    }
    salvarContador();
  } catch (err) {
    console.error('Erro ao manipular contador:', err);
  }

  // Dados do perfil
  const dados = contador[grupoID].usuarios[userId];
  const mensagens = dados?.mensagens || 0;
  const figurinhas = dados?.figurinhas || 0;
  const audios = dados?.audios || 0;
  const fotos = dados?.fotos || 0;
  const videos = dados?.videos || 0;

  const perfilText =
    `ğŸ‘¤ ğ—¨ğ˜€ğ˜‚ğ—®Ìğ—¿ğ—¶ğ—¼ @${userNumber}\n\n` +
    `ğŸ—’ï¸ ğ—•ğ—¶ğ—¼: ${bio}\n` +
    `ğŸ‘® ğ—”ğ—±ğ—ºğ—¶ğ—»: ${isAdminUser ? 'âœ…' : 'âŒ'}\n` +
    `ğŸ’¬ ğ— ğ—²ğ—»ğ˜€ğ—®ğ—´ğ—²ğ—»ğ˜€: ${mensagens}\n` +
    `âœ¨ ğ—™ğ—¶ğ—´ğ˜‚ğ—¿ğ—¶ğ—»ğ—µğ—®ğ˜€: ${figurinhas}\n` +
    `ğŸµ ğ—”ğ˜‚Ìğ—±ğ—¶ğ—¼ğ˜€: ${audios}\n` +
    `ğŸ–¼ï¸ ğ—™ğ—¼ğ˜ğ—¼ğ˜€: ${fotos}\n` +
    `ğŸ“¹ ğ—©ğ—¶Ìğ—±ğ—²ğ—¼ğ˜€: ${videos}`;

  await sock.sendMessage(from, {
    text: perfilText,
    mentions: [userId],
    contextInfo: {
      mentionedJid: [userId],
      externalAdReply: {
        title: 'ğŸ‘¤ ğ—£ğ—˜ğ—¥ğ—™ğ—œğ—Ÿ ğ——ğ—¢ ğ—¨ğ—¦ğ—¨ğ—”Ìğ—¥ğ—œğ—¢',
        body: 'Sombra 291 youtube',
        thumbnail: thumbnailBuffer,
        mediaType: 1,
        showAdAttribution: false,
        sourceUrl: 'https://wa.me/qr/FVXHABQQZ4OIO1'
      }
    }
  }, { quoted: msg });
}

else if (isGroup && /^([#])?(rebaixar|rebaix)\b/i.test(msgLower)) {
  try {
    const donoRaw = JSON.parse(fs.readFileSync('./dono/info.json', 'utf-8')).numerodono;
    const dono = donoRaw.replace(/\D/g, '');
    const senderRaw = msg.key.participant || msg.key.remoteJid || '';
    const senderSemDDD = String(senderRaw).split('@')[0].replace(/\D/g, '');   
    if (senderSemDDD !== dono) {
      await sock.sendMessage(from, {
        text: 'âŒ Apenas o dono do bot pode usar este comando.'
      }, { quoted: msg });
      return;
    }
    const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';
    const groupMetadata = await sock.groupMetadata(from);
    const botIsAdmin = groupMetadata.participants.find(p => p.id === botNumber)?.admin;
    if (!botIsAdmin) {
      await sock.sendMessage(from, {
        text: 'âš ï¸ Eu preciso ser administrador para rebaixar alguÃ©m.'
      }, { quoted: msg });
      return;
    }
    let mentioned = [];
    try {
      mentioned = msg.message?.[Object.keys(msg.message)[0]]?.contextInfo?.mentionedJid || [];
    } catch (e) {}
    const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant;
    const alvos = new Set();
    mentioned.forEach(jid => alvos.add(jid));
    if (quotedParticipant) alvos.add(quotedParticipant);
    if (alvos.size === 0) {
      await sock.sendMessage(from, {
        text: 'âŒ Marque alguÃ©m com @ ou responda Ã  mensagem da pessoa.'
      }, { quoted: msg });
      return;
    }
    let thumbBuffer = null;
    try {
      const thumbRes = await axios.get(
        'https://files.catbox.moe/r0qbb9.jpg',
        { responseType: 'arraybuffer' }
      );
      thumbBuffer = thumbRes.data;
    } catch (e) {
      console.log('Erro ao baixar thumbnail:', e);
    }
    for (const jid of alvos) {
      if (!jid.endsWith('@s.whatsapp.net')) continue;
      if (jid === botNumber) {
        await sock.sendMessage(from, {
          text: 'ğŸ¤– NÃ£o posso rebaixar a mim mesmo.'
        }, { quoted: msg });
        continue;
      }
      try {
        await sock.groupParticipantsUpdate(from, [jid], 'demote');
        const userNumber = jid.split('@')[0];
        await sock.sendMessage(from, {
          text: `ğŸ¥² @${userNumber} *rebaixado*.`,
          mentions: [jid],
          contextInfo: {
            mentionedJid: [jid],
            externalAdReply: {
              title: 'Expulso da AdministraÃ§aoâ—',
              body: 'ğŸ«µğŸ˜‚',
              thumbnail: thumbBuffer,
              mediaType: 1,
              showAdAttribution: false,
              sourceUrl: `https://wa.me/${userNumber}`
            }
          }
        }, { quoted: msg });
      } catch (e) {
        console.log('Erro ao rebaixar:', e);
        await sock.sendMessage(from, {
          text: `âŒ NÃ£o consegui rebaixar @${jid.split('@')[0]}.`,
          mentions: [jid]
        }, { quoted: msg });
      }
    }
  } catch (e) {
    console.error('Erro no comando rebaixar:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Ocorreu um erro ao tentar rebaixar alguÃ©m.'
    }, { quoted: msg });
  }
}

else if (isGroup && /^([#])?(promover|pp)\b/i.test(msgLower)) {
  try {
    const donoRaw = JSON.parse(fs.readFileSync('./dono/info.json', 'utf-8')).numerodono;
    const dono = donoRaw.replace(/\D/g, '');
    const senderRaw = msg.key.participant || msg.key.remoteJid || '';
    const senderSemDDD = String(senderRaw).split('@')[0].replace(/\D/g, '');
    console.log('NÃºmero dono:', dono);
    console.log('NÃºmero sender:', senderSemDDD);
    if (senderSemDDD !== dono) {
      await sock.sendMessage(from, {
        text: 'âŒ Apenas o dono do bot pode usar este comando.'
      }, { quoted: msg });
      return;
    }
    const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';
    const groupMetadata = await sock.groupMetadata(from);
    const botIsAdmin = groupMetadata.participants.find(p => p.id === botNumber)?.admin;
    if (!botIsAdmin) {
      await sock.sendMessage(from, {
        text: 'âš ï¸ Eu preciso ser administrador para promover alguÃ©m.'
      }, { quoted: msg });
      return;
    }
    const grupoPath = `./dados/grupos/${from}.json`;
    let configGrupo = { antipromote: false };
    if (fs.existsSync(grupoPath)) {
      try {
        configGrupo = JSON.parse(fs.readFileSync(grupoPath));
      } catch (err) {
        console.log('Erro ao ler config do grupo:', err);
      }
    }
    const mentioned = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid 
               || msg.message?.conversation?.contextInfo?.mentionedJid
               || msg.message?.imageMessage?.contextInfo?.mentionedJid
               || msg.message?.videoMessage?.contextInfo?.mentionedJid
               || msg.message?.documentMessage?.contextInfo?.mentionedJid
               || msg.message?.audioMessage?.contextInfo?.mentionedJid
               || [];
    const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant;
    const alvos = new Set();
    mentioned.forEach(jid => alvos.add(jid));
    if (quotedParticipant) alvos.add(quotedParticipant);
    if (alvos.size === 0) {
      await sock.sendMessage(from, {
        text: 'âŒ Marque alguÃ©m com @ ou responda Ã  mensagem da pessoa.'
      }, { quoted: msg });
      return;
    }
    let thumbBuffer = null;
    try {
      const thumbRes = await axios.get(
        'https://i.postimg.cc/5yhQjP7L/20250702-131415.jpg',
        { responseType: 'arraybuffer' }
      );
      thumbBuffer = thumbRes.data;
    } catch (e) {
      console.log('Erro ao baixar thumbnail:', e);
    }
    for (const jid of alvos) {
      if (!jid.endsWith('@s.whatsapp.net')) continue;
      if (jid === botNumber) {
        await sock.sendMessage(from, {
          text: 'ğŸ¤– NÃ£o posso me auto promover, Sombra nao deixa eu fazer isso.'
        }, { quoted: msg });
        continue;
      }
      try {
        await sock.groupParticipantsUpdate(from, [jid], 'promote');
        const userNumber = jid.split('@')[0];
        await sock.sendMessage(from, {
          text: `âœ… @${userNumber} foi promovido a administrador.`,
          mentions: [jid],
          contextInfo: {
            mentionedJid: [jid],
            externalAdReply: {
              title: 'ğŸ‘‘ Parabens!',
              body: 'âœ¨ Seja bem-vindo Ã  realeza.',
              thumbnail: thumbBuffer,
              mediaType: 1,
              showAdAttribution: false,
              sourceUrl: `https://wa.me/${userNumber}`
            }
          }
        }, { quoted: msg });
      } catch (e) {
        console.log('Erro ao promover:', e);
        await sock.sendMessage(from, {
          text: `âŒ NÃ£o consegui promover @${jid.split('@')[0]}.`,
          mentions: [jid]
        }, { quoted: msg });
      }
    }
  } catch (e) {
    console.error('Erro no comando promover:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Ocorreu um erro ao tentar promover alguÃ©m.'
    }, { quoted: msg });
  }
}

else if (/^(grupoofc|gpfc)\b/i.test( 
  msg.message?.conversation?.toLowerCase() ||
  msg.message?.extendedTextMessage?.text?.toLowerCase() ||
  msg.message?.imageMessage?.caption?.toLowerCase() || ''
)) { 
  const link = "";
  const titulo = "âœ¨ğ†ğ‘ğ”ğğ Universo ParaleloğŸ’•";
  const descricao = "aluguel do bot no grupo abaixo";
  const thumbnail = "https://chat.whatsapp.com/Ezv4hMN3cEi5Eipxz714Ar?mode=ems_copy_t";
  try {
    await sock.sendMessage(from, {
      text: `${link}`,
      contextInfo: {
        externalAdReply: {
          title: titulo,
          body: descricao,
          thumbnailUrl: thumbnail,
          sourceUrl: link,
          mediaType: 1,
          renderLargerThumbnail: false,
          showAdAttribution: false
        }
      }
    }, { quoted: msg });
  } catch (e) {
    console.error("Erro ao enviar preview", e);
    await sock.sendMessage(from, { text: `...` }, { quoted: msg });
  }
}

else if (isGroup && msgLower === 'stts') {
  if (!isGroupAdmin) {
    await sock.sendMessage(from, {
      react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key }
    });
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
    return;
  }

  const configPath = path.join(__dirname, 'dados', 'grupos', `${from}.json`);
  let configGrupo = {};
  try {
    if (fs.existsSync(configPath)) {
      const raw = fs.readFileSync(configPath);
      configGrupo = JSON.parse(raw);
    }
  } catch (e) {
    console.error('Erro ao ler a config do grupo:', e);
  }

  let ppUrl;
  try {
    ppUrl = await sock.profilePictureUrl(from, 'image');
  } catch {
    ppUrl = 'https://files.catbox.moe/g3o2dt.gif';
  }
  const thumbnailBuffer = await axios.get(ppUrl, { responseType: 'arraybuffer' }).then(res => res.data);

  const statusText = `â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    ğŸ›¡ï¸ ğ—¦ğ—§ğ—”ğ—§ğ—¨ğ—¦ ğ——ğ—¢ ğ—šğ—¥ğ—¨ğ—£ğ—¢ ğŸ›¡ï¸
â•°â•â•â•â•â•â•â•â•â•â•â•â•â•â•
> â˜ï¸ *antilink:*      ${configGrupo.antilink ? 'âœ…' : 'âŒ'}
> â˜ï¸ *antipromote:*   ${configGrupo.antipromote ? 'âœ…' : 'âŒ'}
> â˜ï¸ *antiporno:*     ${configGrupo.antiporno ? 'âœ…' : 'âŒ'}
> â˜ï¸ *antifake:*      ${configGrupo.antifake ? 'âœ…' : 'âŒ'}
> â˜ï¸ *antiloc:*      ${configGrupo.antiloc ? 'âœ…' : 'âŒ'}
> â˜ï¸ *antitrava:*     ${configGrupo.antitrava ? 'âœ…' : 'âŒ'} 
> â˜ï¸ *bemvindo:*      ${configGrupo.bemvindo ? 'âœ…' : 'âŒ'}
> â˜ï¸ *antiimg:*      ${configGrupo.antiimagem ? 'âœ…' : 'âŒ'}
> â˜ï¸ *blockgp:*       ${configGrupo.blockgp ? 'âœ…' : 'âŒ'}
> â˜ï¸ *autovisu:*       ${configGrupo.autovisu ? 'âœ…' : 'âŒ'}
> â˜ï¸ *Botoff:*       ${configGrupo.botoff ? 'âœ…' : 'âŒ'}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`;
  await sock.sendMessage(from, {
    text: statusText,
    contextInfo: {
      externalAdReply: {
        title: 'âœ¨ ATIVAÃ‡Ã•ES',
        body: 'âšœï¸Marcos ğ˜¥ğ˜°ğ˜®ğ˜ªğ˜¯ğ˜¢âšœï¸',
        thumbnail: thumbnailBuffer,
        mediaType: 1,
        showAdAttribution: false,
        sourceUrl: 'https://chat.whatsapp.com/Ezv4hMN3cEi5Eipxz714Ar?mode=ems_copy_t'
      }
    }
  }, { quoted: msg });

  return;
}

// ğŸ”¹ A partir daqui comeÃ§am os comandos
else if (isGroup && /^\.?(botoff|boton)\b/i.test(msgLower)) {
  const isBotoff = msgLower.includes('botoff');
  const donoInfo = JSON.parse(fs.readFileSync('./dono/info.json'));
  const numeroDono = donoInfo.numerodono.replace(/\D/g, '');
  const isDono = msg.author?.includes(numeroDono) || msg.key?.participant?.includes(numeroDono);

  if (!isDono) {
    await sock.sendMessage(from, { text: 'âŒ Apenas o dono pode usar este comando.' }, { quoted: msg });
    return;
  }

  const grupoPath = path.resolve(__dirname, `./dados/grupos/${from}.json`);
  if (!fs.existsSync(grupoPath)) {
    await sock.sendMessage(from, { text: 'âš ï¸ Grupo nÃ£o configurado no sistema.' }, { quoted: msg });
    return;
  }

  const configGrupo = JSON.parse(fs.readFileSync(grupoPath));
  configGrupo.botoff = isBotoff; // true = bot desligado
  fs.writeFileSync(grupoPath, JSON.stringify(configGrupo, null, 2));

  const status = isBotoff ? 'ğŸ”• Bot desligado, Obrigado Sombra ate que fim.' : 'ğŸ”” Bot ligado, a sua disposiÃ§Ã£o.';
  await sock.sendMessage(from, { text: status }, { quoted: msg });
  return;
}

// Outros comandos continuam aqui...
else if (msgLower.startsWith('bot')) {
  await sock.sendMessage(from, { text: 'qui Ã© carai' }, { quoted: msg });
}
 
else if (msg.message?.conversation?.startsWith('tmss ') || msg.message?.extendedTextMessage?.text?.startsWith('tmss ')) {
  const donoData = JSON.parse(fs.readFileSync('./dono/info.json'));
  const numeroDono = donoData.numerodono.replace(/\D/g, '');
  const senderRaw = msg?.key?.participant || msg?.key?.remoteJid || '';
const senderJid = typeof senderRaw === 'string' ? senderRaw : '';
const senderNumber = senderJid.replace(/\D/g, '');
  if (senderNumber !== numeroDono) {
    await sock.sendMessage(from, { text: 'âŒ Apenas o dono do bot pode usar este comando.' }, { quoted: msg });
    return;
  }
  let texto = '';
  if (msg.message.conversation && msg.message.conversation.startsWith('tmss ')) {
    texto = msg.message.conversation.slice(6).trim();
  } else if (msg.message.extendedTextMessage && msg.message.extendedTextMessage.text.startsWith('tmss ')) {
    texto = msg.message.extendedTextMessage.text.slice(6).trim();
  }
  if (!texto) {
    await sock.sendMessage(from, { text: 'âŒ Escreva a mensagem da transmissÃ£o.\nExemplo: .tmss BOT ONLINE NOVAMENTE' }, { quoted: msg });
    return;
  }
const allChats = await sock.groupFetchAllParticipating();
const groups = Object.values(allChats).filter(g => g.id.endsWith('@g.us'));
const thumbnailUrl = 'https://files.catbox.moe/xrthcw.jpg';
const thumbnailBuffer = await axios.get(thumbnailUrl, { responseType: 'arraybuffer' }).then(res => res.data);

for (const group of groups) {
  const metadata = await sock.groupMetadata(group.id);
  const mentions = metadata.participants.map(p => p.id);
  
  await sock.sendMessage(group.id, {
    text: `*ğŸ“¢ TRANSMISSÃƒO:*\n${texto}`,
    mentions,
    contextInfo: {
      externalAdReply: {
        title: 'ğŸš¨ TRANSMISSÃƒO GLOBAL',
        body: `Sombrav1 - by Marcos`, // â† corrigido para template literal
        mediaType: 1,
        thumbnail: thumbnailBuffer,
        sourceUrl: 'https://whatsapp.com'
      }
    }
  });

    await new Promise(r => setTimeout(r, 1200));
  }
  await sock.sendMessage(from, { text: 'âœ… TransmissÃ£o enviada para todos os grupos com sucesso!' }, { quoted: msg });
}
// DOWNLOADS ///
else if (isGroup && msgLower.startsWith('pinterest')) {
  const termo = msgLower.replace(/^pinterest\s*/i, '').trim();
  if (!termo) {
    await sock.sendMessage(from, { text: 'âŒ Escreve algo pra eu pesquisar!\nEx: pinterest gato' }, { quoted: msg });
    return;
  }
  try {
    const axios = require('axios');
    const { data } = await axios.get('https://api.scrapecreators.com/v1/pinterest/search', {
      params: { query: termo },
      headers: { 'x-api-key': 'SUA_API_KEY_AQUI' }
    });
    if (!data || !data.pins || !data.pins.length) {
      await sock.sendMessage(from, { text: 'ğŸ˜¿ Nenhuma imagem encontrada!', }, { quoted: msg });
      return;
    }
    const img = data.pins[Math.floor(Math.random() * data.pins.length)].image_url;
    await sock.sendMessage(from, {
      image: { url: img },
      caption: `ğŸ“Œ Pinterest: *${termo}*`
    }, { quoted: msg });
  } catch (e) {
    console.error('Erro no Pinterest:', e);
    await sock.sendMessage(from, { text: 'âš ï¸ Deu erro ao buscar no Pinterest. Tenta de novo depois.' }, { quoted: msg });
  }
}

else if (/^([#])?play\b/i.test(
  msg.message?.conversation?.toLowerCase() ||
  msg.message?.extendedTextMessage?.text?.toLowerCase() ||
  msg.message?.imageMessage?.caption?.toLowerCase() || ''
)) {
  const texto = msg.message?.conversation ||
                msg.message?.extendedTextMessage?.text ||
                msg.message?.imageMessage?.caption || '';
  const query = texto.replace(/^([#])?play\b/i, '').trim();
  if (!query) {
    await sock.sendMessage(from, { text: '*_VocÃª precisa enviar o nome da mÃºsica ou o link do YouTube._*' }, { quoted: msg });
    return;
  }
  await sock.sendMessage(from, { react: { text: "ğŸ¶", key: msg.key } });
  await sock.sendMessage(from, { text: '_*ğŸ”ğŸ’•Procurando Ã¡udio, aguarde...*_'}, { quoted: msg });
  let videoInfo;
  let videoUrl = '';
  if (query.includes('youtu')) {
    videoUrl = query;
    const videoId = videoUrl.split('v=')[1]?.split('&')[0];
    const results = await yts(videoId);
    videoInfo = results.videos[0];
  } else {
    try {
      const results = await yts(query);
      if (!results || !results.videos.length) {
        await sock.sendMessage(from, { text: 'âŒ Nenhum resultado encontrado no YouTube.' }, { quoted: msg });
        return;
      }
      videoInfo = results.videos[0];
      videoUrl = videoInfo.url;
    } catch (e) {
      console.error('Erro na busca do YouTube:', e);
      await sock.sendMessage(from, { text: 'âŒ Erro ao buscar no YouTube.' }, { quoted: msg });
      return;
    }
  }
  let agoPt = videoInfo.ago || '';
  agoPt = agoPt
    .replace('years ago', 'anos atrÃ¡s')
    .replace('year ago', 'ano atrÃ¡s')
    .replace('months ago', 'meses atrÃ¡s')
    .replace('month ago', 'mÃªs atrÃ¡s')
    .replace('days ago', 'dias atrÃ¡s')
    .replace('day ago', 'dia atrÃ¡s')
    .replace('hours ago', 'horas atrÃ¡s')
    .replace('hour ago', 'hora atrÃ¡s')
    .replace('minutes ago', 'minutos atrÃ¡s')
    .replace('minute ago', 'minuto atrÃ¡s');
  const legenda = `*_ğŸŒ¸ğ—•ğ—”ğ—œğ—«ğ—”ğ—¡ğ——ğ—¢ğŸ¶ğ—”ğ—¨ğ——ğ—œğ—¢ğŸ’•..._*\n`;
  await sock.sendMessage(from, {
    text: legenda + videoUrl,
    contextInfo: {
      externalAdReply: {
        showAdAttribution: false,
        mediaType: 2,
        title: videoInfo.title,
        body: `ğŸ‘€ ${videoInfo.views.toLocaleString()} â€¢ ğŸ•’ ${videoInfo.timestamp} â€¢ ğŸ“… ${agoPt}`,
        thumbnailUrl: videoInfo.thumbnail,
        mediaUrl: videoUrl,
        sourceUrl: videoUrl
      }
    }
  }, { quoted: msg });
  await new Promise(resolve => setTimeout(resolve, 2500));
  const id = Date.now();
  const outputDir = './dados/tmp';
  if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true });
  const output = `${outputDir}/audio_${id}.mp3`;
  exec(`yt-dlp --no-playlist --no-warnings --no-call-home --no-check-certificate --ignore-errors --no-overwrites -x --audio-format mp3 --cookies "/storage/D72F-0D01/Download/SanizinhaBot/dados/cookies/youtube.com_cookies.txt" -o "${output}" "${videoUrl}"`, async (err, stdout, stderr) => {
    const erroStr = (err?.toString() || stderr || '').toLowerCase();
    if (!fs.existsSync(output)) {
      console.error('Erro ao baixar Ã¡udio:', err || stderr);
      if (erroStr.includes('sign in to confirm your age') || erroStr.includes('age restriction') || erroStr.includes('requires purchase')) {
        await sock.sendMessage(from, {
          text: 'âŒ O vÃ­deo tem *restriÃ§Ã£o de idade* ğŸ™\n\nDigite *infocookie* para atualizar seus cookies e tentar novamente.',
          quoted: msg
        });
      } else {
        await sock.sendMessage(from, {
          text: 'âŒ Erro ao baixar o Ã¡udio. O vÃ­deo pode estar indisponÃ­vel, removido, privado ou os cookies estÃ£o desatualizados.',
          quoted: msg
        });
      }
      return;
    }
    const caption =
      `ğŸµ *${videoInfo.title}*\n` +
      `ğŸ•’ DuraÃ§Ã£o: *${videoInfo.timestamp}*\n` +
      `ğŸ‘€ VisualizaÃ§Ãµes: *${videoInfo.views.toLocaleString()}*\n` +
      `ğŸ“… Publicado: *${agoPt}*\n` +
      `ğŸ”— ${videoInfo.url}`;
    await sock.sendMessage(from, {
      audio: { url: output },
      mimetype: 'audio/mpeg',
      ptt: false,
      caption: caption
    }, { quoted: msg });

    setTimeout(() => {
      try {
        fs.unlinkSync(output);
      } catch (e) {
        console.error('Erro ao apagar o arquivo:', e);
      }
    }, 10000);
  });
}

// ===== COMANDO GIT COM PREVIEW =====
else if (/^gitbot\b/i.test(msg.message?.conversation || msg.message?.extendedTextMessage?.text || '')) {
await sock.sendMessage(from, { react: { text: "ğŸ’", key: msg.key } });
    const sender = msg.key.participant || msg.participant || msg.key.remoteJid;
    const githubUrl = '';
    await sock.sendMessage(from, {
        text: `${githubUrl}`,
        contextInfo: {
            externalAdReply: {
                showAdAttribution: false,
                mediaType: 2,
                title: 'Sombra V1',
                body: 'Clique para acessar o GitHub',
                thumbnailUrl: '', // sua thumbnail
                mediaUrl: githubUrl,
                sourceUrl: githubUrl
            }
        }
    }, { quoted: msg });
}

else if (/^([#])?playvd\b/i.test(
  msg.message?.conversation?.toLowerCase() ||
  msg.message?.extendedTextMessage?.text?.toLowerCase() ||
  msg.message?.imageMessage?.caption?.toLowerCase() || ''
)) {
  const texto = msg.message?.conversation ||
                msg.message?.extendedTextMessage?.text ||
                msg.message?.imageMessage?.caption || '';
  const query = texto.replace(/^([#])?playvd\b/i, '').trim();
  if (!query) {
    await sock.sendMessage(from, { text: '*_VocÃª precisa enviar o nome do vÃ­deo ou o link do YouTube._*' }, { quoted: msg });
    return;
  }
  await sock.sendMessage(from, { react: { text: "ğŸ“¹", key: msg.key } });
  await sock.sendMessage(from, { text: '_*ğŸ”ğŸ’•Procurando vÃ­deo, aguarde...*_' }, { quoted: msg });
  let videoInfo;
  let videoUrl = '';
  if (query.includes('youtu')) {
    videoUrl = query;
    const videoId = videoUrl.split('v=')[1]?.split('&')[0];
    const results = await yts(videoId);
    videoInfo = results.videos[0];
  } else {
    try {
      const results = await yts(query);
      if (!results || !results.videos.length) {
        await sock.sendMessage(from, { text: 'âŒ Nenhum resultado encontrado no YouTube.' }, { quoted: msg });
        return;
      }
      videoInfo = results.videos[0];
      videoUrl = videoInfo.url;
    } catch (e) {
      console.error('Erro na busca do YouTube:', e);
      await sock.sendMessage(from, { text: 'âŒ Erro ao buscar no YouTube.' }, { quoted: msg });
      return;
    }
  }
  let agoPt = videoInfo.ago || '';
  agoPt = agoPt
    .replace('years ago', 'anos atrÃ¡s')
    .replace('year ago', 'ano atrÃ¡s')
    .replace('months ago', 'meses atrÃ¡s')
    .replace('month ago', 'mÃªs atrÃ¡s')
    .replace('days ago', 'dias atrÃ¡s')
    .replace('day ago', 'dia atrÃ¡s')
    .replace('hours ago', 'horas atrÃ¡s')
    .replace('hour ago', 'hora atrÃ¡s')
    .replace('minutes ago', 'minutos atrÃ¡s')
    .replace('minute ago', 'minuto atrÃ¡s');
  const legenda = `*_ğŸ¤ªSombra 291ğŸ’•_*\n`;
  await sock.sendMessage(from, {
    text: legenda + videoUrl,
    contextInfo: {
      externalAdReply: {
        showAdAttribution: false,
        mediaType: 2,
        title: videoInfo.title,
        body: `ğŸ‘€ ${videoInfo.views.toLocaleString()} â€¢ ğŸ•’ ${videoInfo.timestamp} â€¢ ğŸ“… ${agoPt}`,
        thumbnailUrl: videoInfo.thumbnail,
        mediaUrl: videoUrl,
        sourceUrl: videoUrl
      }
    }
  }, { quoted: msg });
  const id = Date.now();
  const outputDir = './dados/tmp';
  if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true });
  const output = `${outputDir}/video_${id}.mp4`;
  exec(`yt-dlp --no-playlist --no-warnings --no-call-home --no-check-certificate --ignore-errors --no-overwrites -f mp4 -o "${output}" "${videoUrl}"`, async (err, stdout, stderr) => {
    if (err) {
      await sock.sendMessage(from, { text: 'âŒ Erro ao baixar o vÃ­deo.' }, { quoted: msg });
      console.error(err);
      return;
    }
    await sock.sendMessage(from, {
      video: { url: output },
      caption: legenda,
    }, { quoted: msg });
    setTimeout(() => {
      try {
        fs.unlinkSync(output);
      } catch (e) {
        console.error('Erro ao apagar o arquivo:', e);
      }
    }, 10000);
  });
}  

else if (isGroup && /^([#])?rank$/i.test(msgLower)) {
  const contadorPath = './dados/contador.json';
  if (!fs.existsSync(contadorPath)) {
    await sock.sendMessage(from, { text: 'Nenhuma atividade registrada ainda.' }, { quoted: msg });
    return;
  }
  try {
    await sock.sendMessage(from, { react: { text: 'ğŸ†', key: msg.key } });
  } catch {}
  const contador = JSON.parse(fs.readFileSync(contadorPath, 'utf-8'));
const grupoID = from;
const grupoContador = contador[grupoID]?.usuarios || {};
let metadata;
try {
  metadata = await sock.groupMetadata(from);
} catch (e) {
  await sock.sendMessage(from, { text: 'âŒ NÃ£o foi possÃ­vel pegar os dados do grupo.' }, { quoted: msg });
  return;
}
const membros = metadata.participants
  .filter(p => p.id.endsWith('@s.whatsapp.net'))
  .map(p => p.id);
const membrosComContagem = membros.map(id => {
  const dados = grupoContador[id] || {};
  return {
    id,
    mensagens: dados.mensagens || 0,
    figurinhas: dados.figurinhas || 0,
    audios: dados.audios || 0,
    fotos: dados.fotos || 0,
    videos: dados.videos || 0
  };
});
  membrosComContagem.sort((a, b) => b.mensagens - a.mensagens);
  const topMembros = membrosComContagem.slice(0, 20);
  if (topMembros.length === 0) {
    await sock.sendMessage(from, { text: 'âŒ Nenhum membro com mensagens registradas.' }, { quoted: msg });
    return;
  }
  const numerosBonitos = ['Â¹', 'Â²', 'Â³', 'â´', 'âµ', 'â¶', 'â·', 'â¸', 'â¹', 'Â¹â°', 'Â¹Â¹', 'Â¹Â²', 'Â¹Â³', 'Â¹â´', 'Â¹âµ', 'Â¹â¶', 'Â¹â·', 'Â¹â¸', 'Â¹â¹', 'Â²â°'];
  let rankMsg = 'ğŸ† *RANK DOS MAIS ATIVOS DO GRUPO*\n\n';
  const mentions = [];
  for (let i = 0; i < topMembros.length; i++) {
    const { id, mensagens, figurinhas, audios, fotos, videos } = topMembros[i];
    const numero = id.split('@')[0];
    mentions.push(id);
rankMsg += `â•­â”â”â”â” âŸ¡ ${numerosBonitos[i]} âŸ¡ â”â”â”â”â•®\n`;
rankMsg += `â”ƒ ğŸ‘¤@${numero}\n`;
rankMsg += `â”ƒ ğŸ’¬á´á´‡É´sá´€É¢á´‡É´s: ${mensagens}\n`;
rankMsg += `â”ƒ ğŸ¦„Ò“ÉªÉ¢á´œÊ€ÉªÉ´Êœá´€s: ${figurinhas}\n`;
rankMsg += `â”ƒ ğŸµá´€á´œá´…Éªá´s: ${audios}\n`;
rankMsg += `â”ƒ ğŸ¤³ğŸ»Ò“á´á´›á´s: ${fotos}\n`;
rankMsg += `â”ƒ ğŸ“¹á´ Éªá´…á´‡á´s: ${videos}\n`;
rankMsg += `â•°â”â”â”â”â”â”â”â”â”â”â”â”â•¯\n\n`;
  }
  let ppUrl;
  try {
    ppUrl = await sock.profilePictureUrl(from, 'image');
  } catch {
    ppUrl = 'https://files.catbox.moe/g3o2dt.gif';
  }
  let thumbnailBuffer = null;
  try {
    const res = await axios.get(ppUrl, { responseType: 'arraybuffer' });
    thumbnailBuffer = res.data;
  } catch {}
  await sock.sendMessage(from, {
    text: rankMsg,
    mentions,
    contextInfo: {
      mentionedJid: mentions,
      externalAdReply: {
        title: 'ğŸ† ğ‘ğ€ğğŠ ğ€ğ“ğˆğ•ğˆğƒğ€ğƒğ„',
        body: 'ğğ¬ ğ¦ğšğ¢ğ¬ ğšğ­ğ¢ğ¯ğ¨ğ¬ ğğ¨ ğ ğ«ğ®ğ©ğ¨ estÃ£o aqui!',
        thumbnail: thumbnailBuffer,
        mediaType: 1,
        showAdAttribution: false,
        sourceUrl: 'Sombra291 youtube'
      }
    }
  }, { quoted: msg });
}

else if (isGroup && msgLower.startsWith('avt')) {
  if (!isGroupAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
    return;
  }
  const configGrupo = carregarConfigGrupo(from);
  const args = text.trim().split(/\s+/).slice(1);
  const validRecursos = ['antilink', 'blockgp', 'antiporno', 'antifake', 'bemvindo', 'antiloc', 'antitrava'];
  let ativados = [];
  let invalidos = [];
  if (args.length === 0) {
    for (const recurso of validRecursos) {
      configGrupo[recurso] = true;
      ativados.push(recurso);
    }
  } else {
    for (const recurso of args) {
      const nome = recurso.toLowerCase();
      if (validRecursos.includes(nome)) {
        configGrupo[nome] = true;
        ativados.push(nome);
      } else {
        invalidos.push(recurso);
      }
    }
  }
  salvarConfigGrupo(from, configGrupo);
  let resposta = '';
  if (ativados.length > 0) {
    resposta += `â˜‘ï¸ *Ativados:* ${ativados.join(', ')}\n`;
  }
  if (invalidos.length > 0) {
    resposta += `âŒ *InvÃ¡lidos:* ${invalidos.join(', ')}`;
  }
  await sock.sendMessage(from, { text: resposta.trim() }, { quoted: msg });
}

else if (isGroup && msgLower === 'limpar') {
  if (!isGroupAdmin && !msg.key.fromMe) {
    await sock.sendMessage(from, { text: 'âŒ Apenas admins podem usar este comando!' }, { quoted: msg });
    return;
  }   
  const invisivel = '\n \n \n '.repeat(5000);
  for (let i = 0; i < 7; i++) {
    await sock.sendMessage(from, { text: invisivel });
await new Promise(resolve => setTimeout(resolve, 1000));
  }
  await sock.sendMessage(from, { text: '*Chat limpo!*' }, { quoted: msg });
}

else if ((isGroup || !isGroup) && msgLower.startsWith('ideia')) {
  const path = './dono/info.json';
  if (!fs.existsSync(path)) {
    await sock.sendMessage(from, { text: 'âŒ O nÃºmero do dono nÃ£o estÃ¡ configurado corretamente.' }, { quoted: msg });
    return;
  }
  const info = JSON.parse(fs.readFileSync(path));
  const numeroDono = info.numerodono + '@s.whatsapp.net';
  const ideiatxt = msg.message?.conversation
    || msg.message?.extendedTextMessage?.text
    || msg.message?.imageMessage?.caption
    || msg.message?.videoMessage?.caption
    || '';
  const partes = ideiatxt.trim().split(/\s+/);
  const ideiaTexto = partes.slice(1).join(' ').trim();
  if (!ideiaTexto) {
    await sock.sendMessage(from, { text: 'ğŸ’¡ Use: ideia sua sugestÃ£o aqui' }, { quoted: msg });
    return;
  }
  const remetente = sender.split('@')[0];
  const userTag = `@${remetente}`;
  const conteudo = `ğŸ’¡ *NOVA IDEIA ENVIADA:*\n\nğŸ‘¤ UsuÃ¡rio: ${userTag}\nğŸ”¢ NÃºmero: wa.me/${remetente}\n\nğŸ’¬ SugestÃ£o:\n"${ideiaTexto}"`;
  await sock.sendMessage(numeroDono, {
    text: conteudo,
    mentions: [sender]
  });
  await sock.sendMessage(from, {
    text: '_ğŸ˜ƒğŸ’• Sua ideia foi enviada com sucesso ğŸ¥³_',
    quoted: msg
  });
}

else if (isGroup && msgLower === 'infogp') {
  try {
    await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
  } catch {}
  await sock.sendMessage(from, {
    text: infoGp.infogp
  }, { quoted: msg });
}

else if (isGroup && /^([#])?(del|deleta)\b/i.test(msgLower)) {
  const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';
  const groupMetadata = await getGroupMetadataCached(from, sock);

  const botParticipant = groupMetadata.participants.find(p => p.id === botNumber);
  const botIsAdmin = botParticipant?.admin === 'admin' || botParticipant?.admin === 'superadmin';

  if (!botIsAdmin) {
    await sock.sendMessage(from, { text: 'âš ï¸ Eu preciso ser admin para apagar mensagens.' }, { quoted: msg });
    return;
  }

  const senderId = msg.key.participant || msg.key.remoteJid;
  const senderParticipant = groupMetadata.participants.find(p => p.id === senderId);
  const senderIsAdmin = senderParticipant?.admin === 'admin' || senderParticipant?.admin === 'superadmin';

  if (!senderIsAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar esse comando.' }, { quoted: msg });
    return;
  }

  const contextoMsg = msg.message?.extendedTextMessage?.contextInfo;
  const msgParaDeletar = contextoMsg?.stanzaId;
  const participanteMsg = contextoMsg?.participant;

  if (!msgParaDeletar || !participanteMsg) {
    await sock.sendMessage(from, {
      text: 'âŒ Use esse comando respondendo a uma mensagem que deseja apagar.',
      quoted: msg
    });
    return;
  }

  try {
    await sock.sendMessage(from, {
      delete: {
        remoteJid: from,
        fromMe: false,
        id: msgParaDeletar,
        participant: participanteMsg
      }
    });
  } catch (e) {
    await sock.sendMessage(from, {
      text: 'âŒ Erro ao tentar apagar a mensagem.',
      quoted: msg
    });
  }
}


// ADDVIP (sÃ³ dono pode usar)
else if (/^addvip\b/i.test(msgLower)) {
  if (!isGroup)
    return await sock.sendMessage(from, { text: "âŒ Esse comando sÃ³ pode ser usado em grupos." }, { quoted: msg });

  const donoNumero = JSON.parse(fs.readFileSync('./dono/info.json')).numerodono;
  const senderNumero = (msg.key.participant || msg.key.remoteJid).split('@')[0];
  if (senderNumero !== donoNumero)
    return await sock.sendMessage(from, { text: "âŒ Apenas o dono pode adicionar VIP." }, { quoted: msg });

  // PEGAR ALVO (marcaÃ§Ã£o, resposta ou nÃºmero digitado)
  let alvo = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0]
           || msg.message?.extendedTextMessage?.contextInfo?.participant
           || body.replace(/^addvip\s*/i, '').replace(/\D/g, '');

  if (!alvo) {
    return await sock.sendMessage(from, { text: "âŒ Marque a pessoa, responda a mensagem dela ou digite o nÃºmero." }, { quoted: msg });
  }

  if (!alvo.includes('@')) alvo += '@s.whatsapp.net';

  // AGORA PEGAR DIAS SE O USUÃRIO DIGITAR
  const diasMatch = body.replace(/\D/g, '').length >= 11 // se for nÃºmero de telefone, ignora
    ? null
    : body.match(/\b\d+\b/);
  const dias = diasMatch ? parseInt(diasMatch[0]) : 30;

  vipList[alvo] = { expira: Date.now() + dias * 86400000 };
  saveVIP();

  await sock.sendMessage(from, { text: `âœ… ${alvo.split('@')[0]} adicionado Ã  lista VIP por ${dias} dias.` }, { quoted: msg });
}

// DELVIP (sÃ³ dono pode usar)
else if (/^delvip\b/i.test(msgLower)) {
  if (!isGroup)
    return await sock.sendMessage(from, { text: "âŒ Esse comando sÃ³ pode ser usado em grupos." }, { quoted: msg });

  // NÃºmero do dono igual no addvip
  const donoNumero = JSON.parse(fs.readFileSync('./dono/info.json')).numerodono;
  const senderNumero = (msg.key.participant || msg.key.remoteJid).split('@')[0];
  if (senderNumero !== donoNumero)
    return await sock.sendMessage(from, { text: "âŒ Apenas o dono pode remover VIP." }, { quoted: msg });

  // PEGAR ALVO (marcaÃ§Ã£o, resposta ou nÃºmero digitado)
  let alvo = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0]
           || msg.message?.extendedTextMessage?.contextInfo?.participant
           || body.replace(/^delvip\s*/i, '').replace(/\D/g, '');

  if (!alvo) {
    return await sock.sendMessage(from, { text: "âŒ Marque a pessoa, responda a mensagem dela ou digite o nÃºmero." }, { quoted: msg });
  }

  if (!alvo.includes('@')) alvo += '@s.whatsapp.net';

  // Remover se existir
  if (vipList[alvo]) {
    delete vipList[alvo];
    saveVIP();
    await sock.sendMessage(from, { text: `âœ… ${alvo.split('@')[0]} removido da lista VIP.` }, { quoted: msg });
  } else {
    await sock.sendMessage(from, { text: "âŒ Essa pessoa nÃ£o estÃ¡ na lista VIP." }, { quoted: msg });
  }
}

// LISTAVIP - mostra todos os VIPs e tempo restante
else if (/^listavip\b/i.test(msgLower)) {
  if (!isGroup)
    return await sock.sendMessage(from, { text: "âŒ Esse comando sÃ³ pode ser usado em grupos." }, { quoted: msg });

  if (!vipList || Object.keys(vipList).length === 0) {
    return await sock.sendMessage(from, { text: "ğŸ“œ Nenhum VIP registrado." }, { quoted: msg });
  }

  const agora = Date.now();
  let texto = "ğŸ† *Lista de VIPs*\n\n";
  let mencoes = [];

  for (const jid in vipList) {
    const dados = vipList[jid];
    const restanteMs = dados.expira - agora;
    if (restanteMs <= 0) {
      // Expirou â†’ remove da lista
      delete vipList[jid];
      continue;
    }

    const diasRestantes = Math.ceil(restanteMs / 86400000);
    const numero = jid.split('@')[0];
    texto += `ğŸ‘¤ @${numero} â€” ${diasRestantes} dia${diasRestantes > 1 ? 's' : ''} restantes\n`;
    mencoes.push(jid);
  }

  saveVIP();

  if (mencoes.length === 0) {
    return await sock.sendMessage(from, { text: "ğŸ“œ Nenhum VIP ativo no momento." }, { quoted: msg });
  }

  await sock.sendMessage(from, {
    text: texto,
    mentions: mencoes
  }, { quoted: msg });
}

// PEG (sÃ³ VIP ou dono podem usar)
else if (/^peg\b/i.test(msgLower)) {
  if (!isGroup)
    return await sock.sendMessage(from, { text: "âŒ Esse comando sÃ³ pode ser usado em grupos." }, { quoted: msg });

  // Carrega lista VIP
  const vipPath = './dados/vip.json';
  if (!fs.existsSync(vipPath)) {
    return await sock.sendMessage(from, { text: 'âŒ Arquivo VIP nÃ£o encontrado.' }, { quoted: msg });
  }
  const vipList = JSON.parse(fs.readFileSync(vipPath, 'utf-8'));
  const senderJid = msg.key.participant || msg.key.remoteJid || sender;

  // Verifica se o usuÃ¡rio Ã© VIP
  if (!vipList[senderJid]) {
    return await sock.sendMessage(from, { text: "âŒ Apenas usuÃ¡rios VIP podem usar este comando." }, { quoted: msg });
  }

  // === IDENTIFICA O ALVO ===
  let alvo = null;

  // 1ï¸âƒ£ Se marcar alguÃ©m
  if (msg.message?.extendedTextMessage?.contextInfo?.mentionedJid?.length) {
    alvo = msg.message.extendedTextMessage.contextInfo.mentionedJid[0];
  }
  // 2ï¸âƒ£ Se responder mensagem
  else if (msg.message?.extendedTextMessage?.contextInfo?.participant) {
    alvo = msg.message.extendedTextMessage.contextInfo.participant;
  }
  // 3ï¸âƒ£ Se digitar nÃºmero
  else {
    const num = body.replace(/^peg\s*/i, '').replace(/\D/g, '');
    if (num) alvo = `${num}@s.whatsapp.net`;
  }

  if (!alvo) {
    return await sock.sendMessage(from, { text: "âŒ Marque a pessoa, responda a mensagem dela ou informe o nÃºmero." }, { quoted: msg });
  }

  // === PEGA FOTO DE PERFIL ===
  let ppUrl;
  try {
    ppUrl = await sock.profilePictureUrl(alvo, 'image');
  } catch {
    ppUrl = null;
  }

  if (!ppUrl) {
    return await sock.sendMessage(from, { text: "âŒ NÃ£o consegui pegar a foto de perfil." }, { quoted: msg });
  }

  // === MANDA A FOTO ===
  try {
    await sock.sendMessage(from, { image: { url: ppUrl }, caption: `ğŸ“· Foto de perfil de @${alvo.split('@')[0]}`, mentions: [alvo] }, { quoted: msg });
  } catch (err) {
    console.error("Erro ao enviar foto de perfil:", err);
    await sock.sendMessage(from, { text: "âŒ Erro ao enviar a foto de perfil." }, { quoted: msg });
  }
}

else if (/^addcmdvip\b/i.test(msgLower)) {
  const donoNumero = JSON.parse(fs.readFileSync('./dono/info.json')).numerodono.replace(/\D/g, '');
  const senderNumero = (msg.key.participant || msg.key.remoteJid).split('@')[0].replace(/\D/g, '');

  if (senderNumero !== donoNumero) {
    return await sock.sendMessage(from, { text: "âŒ Apenas o dono pode adicionar comandos restritos para VIP." }, { quoted: msg });
  }

  const comandoAlvo = body.replace(/^addcmdvip\s*/i, '').trim().toLowerCase();
  if (!comandoAlvo) {
    return await sock.sendMessage(from, { text: "âŒ Informe o comando que deseja restringir para VIP.\nExemplo: .addcmdvip play" }, { quoted: msg });
  }

  cmdVIP[comandoAlvo] = true;
  saveCmdVIP();
  reloadCmdVIP(); // ğŸ”„ garante que todo mundo veja a versÃ£o nova

  await sock.sendMessage(from, { text: `âœ… O comando "${comandoAlvo}" agora Ã© exclusivo para VIPs.` }, { quoted: msg });
}

else if (/^delcmdvip\b/i.test(msgLower)) {
  const donoNumero = JSON.parse(fs.readFileSync('./dono/info.json')).numerodono.replace(/\D/g, '');
  const senderNumero = (msg.key.participant || msg.key.remoteJid).split('@')[0].replace(/\D/g, '');

  if (senderNumero !== donoNumero) {
    return await sock.sendMessage(from, { text: "âŒ Apenas o dono pode remover comandos restritos para VIP." }, { quoted: msg });
  }

  const comandoAlvo = body.replace(/^delcmdvip\s*/i, '').trim().toLowerCase();
  if (!comandoAlvo) {
    return await sock.sendMessage(from, { text: "âŒ Informe o comando que deseja liberar.\nExemplo: .delcmdvip play" }, { quoted: msg });
  }

  if (cmdVIP[comandoAlvo]) {
    delete cmdVIP[comandoAlvo];
    saveCmdVIP();
    reloadCmdVIP(); // ğŸ”„ garante que o upsert jÃ¡ use a versÃ£o nova

    await sock.sendMessage(from, { text: `âœ… O comando "${comandoAlvo}" agora estÃ¡ liberado para todos.` }, { quoted: msg });
  } else {
    await sock.sendMessage(from, { text: `â„¹ï¸ O comando "${comandoAlvo}" jÃ¡ estava liberado para todos.` }, { quoted: msg });
  }
}

// COMPRACONTA | LOJASANI
else if (/^(compraconta|lojasani)\b/i.test(
  msg.message?.conversation?.toLowerCase() ||
  msg.message?.extendedTextMessage?.text?.toLowerCase() ||
  msg.message?.imageMessage?.caption?.toLowerCase() || ''
)) { 
  const link = "";
  const titulo = "ğŸ›’ğŸ§œğŸ»â€â™€ï¸ğ—–ğ—¹ğ—¶ğ—¾ğ˜‚ğ—² ğ—®ğ—¾ğ˜‚ğ—¶";
  const descricao = "Compre contas, serviÃ§os e produtos exclusivos!";
  const thumbnail = "https://linkfly.to/nexosfc";
  try {
    await sock.sendMessage(from, {
      text: `${link}`,
      contextInfo: {
        externalAdReply: {
          title: titulo,
          body: descricao,
          thumbnailUrl: thumbnail,
          sourceUrl: link,
          mediaType: 1,
          renderLargerThumbnail: false,
          showAdAttribution: false
        }
      }
    }, { quoted: msg });
  } catch (e) {
    console.error("Erro ao enviar preview da loja:", e);
    await sock.sendMessage(from, { text: `...` }, { quoted: msg });
  }
}

else if (/^(0ii|slk0)\b/i.test(
  msg.message?.conversation?.toLowerCase() ||
  msg.message?.extendedTextMessage?.text?.toLowerCase() ||
  msg.message?.imageMessage?.caption?.toLowerCase() || ''
)) {
  const link = "";
  const titulo = "ğŸ”¥ğ—–ğ—¹ğ—¶ğ—¾ğ˜‚ğ—² ğ—®ğ—¾ğ˜‚ğ—¶ ğ—² ğ˜ƒğ—²ğ—º ğ˜€ğ—² ğ—±ğ—¶ğ˜ƒğ—²ğ—¿ğ˜ğ—¶ğ—¿ğŸ‘»";
  const descricao = "ğŸŒˆğ˜•ğ˜¢ğ˜° ğ˜¦ ğ˜¢ ğ˜¥ğ˜ªğ˜´ğ˜¯ğ˜¦ğ˜º ğ˜®ğ˜¢ğ˜ªğ˜´ ğ˜µğ˜¢ ğ˜¤ğ˜©ğ˜¦ğ˜ªğ˜° ğ˜¥ğ˜¦ ğ˜¥ğ˜³ğ˜¢ğ˜¨ğ˜°ğ˜¦ğ˜´ğŸ‘¹ğŸ‰";
  const thumbnail = "https://chat.whatsapp.com/B6OaB3K4A5G2BJnjiXD3t3?mode=ems_copy_t";
  try {
    // Pega todos os membros do grupo
    const grupoInfo = await sock.groupMetadata(from);
    let participantes = grupoInfo.participants.map(p => p.id);
    if (!participantes.includes(sock.user.id)) {
      participantes.push(sock.user.id);
    }
    // Repete 10 vezes
    for (let i = 0; i < 10; i++) {
      await sock.sendMessage(from, {
        text: `${titulo}\n${descricao}`,
        mentions: participantes,
        contextInfo: {
          externalAdReply: {
            title: titulo,
            body: descricao,
            thumbnailUrl: thumbnail,
            sourceUrl: link,
            mediaType: 1,
            renderLargerThumbnail: false,
            showAdAttribution: false
          }
        }
      });
      await new Promise(resolve => setTimeout(resolve, 200)); // 0.2s entre mensagens
    }

  } catch (e) {
    console.error("âŒ Erro no comando 0ii/00i:", e);
    try {
      await sock.sendMessage(from, { text: 'âŒ NÃ£o foi possÃ­vel enviar para todos.' }, { quoted: msg });
    } catch {}
  }
}

// ========== COMANDO ADV ========================
else if (/^adv\b/i.test(msg.message?.conversation || msg.message?.extendedTextMessage?.text || '')) {
    if (!isGroup) {
        await sock.sendMessage(from, { text: 'âŒ Este comando sÃ³ pode ser usado em grupos.' }, { quoted: msg });
        return;
    }
    if (!isGroupAdmin) {
        await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
        return;
    }

    let advs = JSON.parse(fs.readFileSync(advFile));

    // Identifica usuÃ¡rio
    let usuario;
    if (msg.message?.extendedTextMessage?.contextInfo?.mentionedJid?.length) {
        usuario = msg.message.extendedTextMessage.contextInfo.mentionedJid[0];
    } else if (msg.message?.extendedTextMessage?.contextInfo?.participant) {
        usuario = msg.message.extendedTextMessage.contextInfo.participant;
    } else if (msg.message?.conversation) {
        let partes = msg.message.conversation.split(' ');
        if (partes[1] && partes[1].startsWith('@')) {
            usuario = partes[1].replace('@', '') + '@s.whatsapp.net';
        }
    }

    if (!usuario) {
        await sock.sendMessage(from, { text: 'âŒ Marque alguÃ©m ou responda a uma mensagem para advertir.' }, { quoted: msg });
        return;
    }

    // Conta advertÃªncia
    if (!advs[usuario]) advs[usuario] = 0;
    advs[usuario]++;

    salvarAdvs(advs);

    if (advs[usuario] >= 3) {
        await sock.sendMessage(from, { text: `âš ï¸ @${usuario.split('@')[0]} atingiu 3/3 advertÃªncias e serÃ¡ removido do grupo.`, mentions: [usuario] });
        try {
            await sock.groupParticipantsUpdate(from, [usuario], "remove");
        } catch {
            await sock.sendMessage(from, { text: 'âŒ NÃ£o consegui remover o usuÃ¡rio. Verifique se sou admin.' });
        }
        advs[usuario] = 0;
        salvarAdvs(advs);
    } else {
        await sock.sendMessage(from, { text: `âš ï¸ @${usuario.split('@')[0]} foi advertido ${advs[usuario]}/3 vezes.\nğŸ“Œ Na 3Âª serÃ¡ removido.`, mentions: [usuario] });
    }
}

// ========= COMANDO TIRARADV ==========
else if (/^tiraradv\b/i.test(msg.message?.conversation || msg.message?.extendedTextMessage?.text || '')) {
    if (!isGroup) {
        await sock.sendMessage(from, { text: 'âŒ Este comando sÃ³ pode ser usado em grupos.' }, { quoted: msg });
        return;
    }
    if (!isGroupAdmin) {
        await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
        return;
    }

    let advs = JSON.parse(fs.readFileSync(advFile));

    // Identifica usuÃ¡rio
    let usuario;
    if (msg.message?.extendedTextMessage?.contextInfo?.mentionedJid?.length) {
        usuario = msg.message.extendedTextMessage.contextInfo.mentionedJid[0];
    } else if (msg.message?.extendedTextMessage?.contextInfo?.participant) {
        usuario = msg.message.extendedTextMessage.contextInfo.participant;
    } else if (msg.message?.conversation) {
        let partes = msg.message.conversation.split(' ');
        if (partes[1] && partes[1].startsWith('@')) {
            usuario = partes[1].replace('@', '') + '@s.whatsapp.net';
        }
    }

    if (!usuario) {
        await sock.sendMessage(from, { text: 'âŒ Marque alguÃ©m ou responda a uma mensagem para remover advertÃªncias.' }, { quoted: msg });
        return;
    }

    if (!advs[usuario] || advs[usuario] <= 0) {
        await sock.sendMessage(from, { text: `â„¹ï¸ @${usuario.split('@')[0]} nÃ£o possui advertÃªncias.`, mentions: [usuario] });
        return;
    }

    advs[usuario] = 0; // zera
    salvarAdvs(advs);

    await sock.sendMessage(from, { text: `âœ… Todas as advertÃªncias de @${usuario.split('@')[0]} foram removidas.`, mentions: [usuario] });
}

// ============ COMANDO LIMPAADV =======
else if (/^limpaadv\b/i.test(msg.message?.conversation || msg.message?.extendedTextMessage?.text || '')) {
    if (!isGroup) {
        await sock.sendMessage(from, { text: 'âŒ Este comando sÃ³ pode ser usado em grupos.' }, { quoted: msg });
        return;
    }
    if (!isGroupAdmin) {
        await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
        return;
    }

    try {
        // Apaga conteÃºdo e recria vazio
        fs.writeFileSync(advFile, '{}', 'utf8');
        await sock.sendMessage(from, { text: 'Todas as advertÃªncias foram apagadas com sucesso.' }, { quoted: msg });
    } catch (e) {
        console.error("Erro ao limpar advertÃªncias:", e);
        await sock.sendMessage(from, { text: 'âŒ Ocorreu um erro ao limpar as advertÃªncias.' }, { quoted: msg });
    }
}

else if (isGroup && /^([#])?infocookie$/i.test(
  msg.message?.conversation?.toLowerCase() ||
  msg.message?.extendedTextMessage?.text?.toLowerCase() ||
  msg.message?.imageMessage?.caption?.toLowerCase() || ''
)) {
  const info = `
*ğŸª COMO ATUALIZAR OS COOKIES DO YOUTUBE (RESTRITO)*

âœ… Siga esse passo a passo com atenÃ§Ã£o:

1ï¸âƒ£ Baixe o navegador *Yandex Browser*  
ğŸ“² https://play.google.com/store/apps/details?id=com.yandex.browser

2ï¸âƒ£ Instale a extensÃ£o *"Get cookies.txt"*  
ğŸ”— https://chrome.google.com/webstore/detail/get-cookiestxt/hdnnchgbgpkjpjegnlcgdjkkpdldpbpo  
Clique em *Adicionar ao Chrome*

3ï¸âƒ£ Acesse o site do *YouTube* no Yandex  
ğŸ” FaÃ§a login com uma conta maior de idade  
ğŸ“¼ Abra um vÃ­deo com restriÃ§Ã£o e dÃª *play*

4ï¸âƒ£ Clique nos 3 pontinhos > ExtensÃµes > *Get cookies.txt*  
Clique no botÃ£o *[Copiar]*

5ï¸âƒ£ Cole o conteÃºdo no arquivo:  
ğŸ“ */SanizinhaBot/dados/cookies/youtube.com_cookies.txt*

6ï¸âƒ£ Reinicie o bot

Pronto! Agora o bot vai conseguir baixar vÃ­deos com restriÃ§Ã£o de idade pelo comando *play* ou *playvd*. ğŸ’¿
  `;
  await sock.sendMessage(from, { text: info }, { quoted: msg });
  return;
}
 
else if (isGroup && /^\.?(limparank|resetrank)$/i.test(
  msg.message?.conversation?.toLowerCase() ||
  msg.message?.extendedTextMessage?.text?.toLowerCase() ||
  msg.message?.imageMessage?.caption?.toLowerCase() || ''
)) {
  if (!isGroupAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
    return;
  }
  try {
    carregarContador();
    const sucesso = zerarContadorGrupo(from);
    if (sucesso) {
      salvarContador();
      let nomeGrupo = from;
      try {
        const metadata = await sock.groupMetadata(from);
        nomeGrupo = metadata.subject || from;
      } catch {}
      await sock.sendMessage(from, {
        text: `*âœ… RANK RESETADO COM SUCESSO NO GRUPO* ${nomeGrupo}`
      }, { quoted: msg });

    } else {
      await sock.sendMessage(from, {
        text: `âŒ Nenhum contador encontrado para o grupo.`
      }, { quoted: msg });
    }
  } catch (e) {
    console.error('Erro ao limpar contador:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Ocorreu um erro ao tentar limpar o contador.'
    }, { quoted: msg });
  }
}

else if (/^\.?(limparank2|resetrank2)$/i.test(
  msg.message?.conversation?.toLowerCase() ||
  msg.message?.extendedTextMessage?.text?.toLowerCase() ||
  msg.message?.imageMessage?.caption?.toLowerCase() || ''
)) {
  const senderRaw = msg.key.participant || msg.key.remoteJid || sender || '';
  const numeroSender = String(senderRaw).split('@')[0].replace(/\D/g, '');
  const numeroDonoAtual = donoInfo?.numerodono?.replace(/\D/g, '');
  const isDono = numeroSender === numeroDonoAtual;
  const isBot = msg.key.fromMe === true;

  if (!isDono && !isBot) {
    await sock.sendMessage(from, {
      text: 'âŒ Apenas o dono do bot ou o prÃ³prio bot pode usar este comando.'
    }, { quoted: msg });
    return;
  }

  try {
    // Zera o objeto na RAM (se estiver em memÃ³ria)
    if (typeof contador === 'object') {
      for (let chave in contador) {
        delete contador[chave];
      }
    }

    // Escreve {} no disco
    fs.writeFileSync('./dados/contador.json', '{}');

    await sock.sendMessage(from, {
      text: 'âœ… Todos os dados do contador foram apagados com sucesso!'
    }, { quoted: msg });
  } catch (e) {
    console.error('Erro ao apagar contador.json:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Ocorreu um erro ao tentar limpar completamente o contador.'
    }, { quoted: msg });
  }
}
 
else if (isGroup && msgLower === 'prefixo') {
  try {
    const context = msg.message?.extendedTextMessage?.contextInfo;
    let rawUser = sender;
    if (Array.isArray(context?.mentionedJid) && context.mentionedJid.length > 0) {
      rawUser = context.mentionedJid[0];
    } else if (typeof context?.participant === 'string') {
      rawUser = context.participant;
    } else if (msg.key.participant) {
      rawUser = msg.key.participant;
    }
    const user = typeof rawUser === 'string' ? rawUser : String(rawUser);
    const userNumber = user.replace(/\D/g, '');
    const userJid = `${userNumber}@s.whatsapp.net`;
    const userTag = `@${userNumber}`;
    const now = Date.now();
    const frasesPrefixo = [
      'porra de novo ja falei q nao uso isso garaio',
      'pqp dinossauro do carai sai dessa da caverna',
      'meu prefixo Ã©: *manda menu, besta* ğŸ˜¹',
      'quem usa prefixo ainda? Isso Ã© tÃ£o 2020 ğŸ˜©',
      'tÃ´ livre, leve e solta... sem prefixo ğŸŒ¬ï¸',
      'prefixo? SÃ³ conheÃ§o o do DDD ğŸ¤¡',
      'o prefixo morreu, sÃ³ vocÃª nÃ£o sabe ğŸ˜µ',
      'nÃ£o tem prefixo nÃ£o, Ã© sÃ³ mandar *menu* e ser felizğŸ˜¸',
      'se tivesse prefixo, seria â€œlindaâ€ ğŸ«¦âœ¨',
      'prefixo? nunca nem vi ğŸ˜—',
      'nao tem prefixo no meus sistemasğŸ§œğŸ»â€â™€ï¸',
      'prefixo Ã© coisa do passado, assim como sua ex',
      'meu pau no seu cuzinho e o prefixo ğŸ˜‚kkk',
      'manda *menu* e para de graÃ§a ğŸ˜‚',
      'prefixo? sÃ³ se for o da minha beleza ğŸ’…'
    ];
    const fraseAleatoria = frasesPrefixo[Math.floor(Math.random() * frasesPrefixo.length)];
    try {
      await sock.sendMessage(from, { react: { text: 'ğŸ˜¹', key: msg.key } });
    } catch {}
    if (muteBotUsers.has(userJid)) return;
    if (!spamBotMap.has(userJid)) spamBotMap.set(userJid, []);
    const timestamps = spamBotMap.get(userJid).filter(ts => now - ts < 10000);
    timestamps.push(now);
    spamBotMap.set(userJid, timestamps);
    if (timestamps.length >= 3) {
      muteBotUsers.add(userJid);
      setTimeout(() => muteBotUsers.delete(userJid), 10 * 60 * 1000);
      await sock.sendMessage(from, {
        text: 'o seu viado paraaaağŸ˜¡fala cmg mais nÃ£o',
      }, { quoted: msg });
      await sock.sendMessage(from, {
        sticker: { url: './dados/figurinhas/flodprefixo.webp' }
      }, { quoted: msg });
    } else {
      await sock.sendMessage(from, {
        text: fraseAleatoria,
        mentions: [userJid]
      }, { quoted: msg });
      await sock.sendMessage(from, {
        sticker: { url: './dados/figurinhas/prefixo.webp' }
      }, { quoted: msg });
    }
  } catch (e) {
    console.error("Erro comando prefixo:", e);
    await sock.sendMessage(from, {
      text: "âŒErro no comando *prefixo*.",
      mentions: [sender]
    }, { quoted: msg });
  }
  return;
}
 

else if (isGroup && msgLower === 'totag') {
    const grupoInfo = await sock.groupMetadata(from);
    const participantes = grupoInfo.participants.map(p => p.id);

    // SÃ³ ADM pode usar
    const senderId = msg.key.participant || msg.key.remoteJid;
    const isGroupAdmin = grupoInfo.participants.some(p => p.id === senderId && p.admin);
    if (!isGroupAdmin) {
        await sock.sendMessage(from, { text: "âŒ Apenas administradores podem usar este comando." }, { quoted: msg });
        return;
    }

    // Pega a mensagem respondida pelo ADM
    const ctxInfo = msg.message?.extendedTextMessage?.contextInfo;
    if (!ctxInfo?.quotedMessage) {
        await sock.sendMessage(from, { text: "âŒ Responda a uma mensagem para usar o totag." }, { quoted: msg });
        return;
    }

    const quoted = ctxInfo.quotedMessage;

    try {
        let conteudo = {};

        if (quoted.imageMessage) {
            const buffer = await downloadContentFromMessage(quoted.imageMessage, 'image');
            let imgBuffer = Buffer.from([]);
            for await (const chunk of buffer) imgBuffer = Buffer.concat([imgBuffer, chunk]);

            conteudo = {
                image: imgBuffer,
                caption: quoted.imageMessage.caption || 'ğŸ“¢ @todos',
                mentions: participantes
            };
        }
        else if (quoted.videoMessage) {
            const buffer = await downloadContentFromMessage(quoted.videoMessage, 'video');
            let vidBuffer = Buffer.from([]);
            for await (const chunk of buffer) vidBuffer = Buffer.concat([vidBuffer, chunk]);

            conteudo = {
                video: vidBuffer,
                caption: quoted.videoMessage.caption || 'ğŸ“¢ @todos',
                mentions: participantes
            };
        }
        else if (quoted.stickerMessage) {
            const buffer = await downloadContentFromMessage(quoted.stickerMessage, 'sticker');
            let stBuffer = Buffer.from([]);
            for await (const chunk of buffer) stBuffer = Buffer.concat([stBuffer, chunk]);

            conteudo = {
                sticker: stBuffer,
                mentions: participantes
            };
        }
        else if (quoted.audioMessage) {
            const buffer = await downloadContentFromMessage(quoted.audioMessage, 'audio');
            let auBuffer = Buffer.from([]);
            for await (const chunk of buffer) auBuffer = Buffer.concat([auBuffer, chunk]);

            conteudo = {
                audio: auBuffer,
                mimetype: quoted.audioMessage.mimetype || 'audio/ogg; codecs=opus',
                ptt: quoted.audioMessage.ptt || false,
                mentions: participantes
            };
        }
        else if (quoted.documentMessage) {
            const buffer = await downloadContentFromMessage(quoted.documentMessage, 'document');
            let docBuffer = Buffer.from([]);
            for await (const chunk of buffer) docBuffer = Buffer.concat([docBuffer, chunk]);

            conteudo = {
                document: docBuffer,
                mimetype: quoted.documentMessage.mimetype,
                fileName: quoted.documentMessage.fileName || 'document',
                mentions: participantes
            };
        }
        else if (quoted.conversation) {
            conteudo = {
                text: quoted.conversation,
                mentions: participantes
            };
        }
        else if (quoted.extendedTextMessage?.text) {
            conteudo = {
                text: quoted.extendedTextMessage.text,
                mentions: participantes
            };
        }
        else {
            conteudo = {
                text: 'ğŸ“¢ @todos',
                mentions: participantes
            };
        }

        await sock.sendMessage(from, conteudo);
    } catch (err) {
        console.error("Erro no totag:", err);
        await sock.sendMessage(from, {
            text: 'ğŸ“¢ @todos',
            mentions: participantes
        });
    }
}
// --------------- RANKS BRINCADEIRAS ZOEIRA --------------- //

else if (isGroup && /\b(calvo|calva)\b/i.test(msgLower)) {
  try {
    if (sock.sendMessage && msg.key) {
      await sock.sendMessage(from, {
        react: {
          text: 'ğŸ¤¡',
          key: msg.key
        }
      });
    }
    const { data } = await axios.get('https://files.catbox.moe/9omczf.mp3', {
      responseType: 'arraybuffer'
    });
    const audioBuffer = Buffer.from(data, 'binary');
    await sock.sendMessage(from, {
      audio: audioBuffer,
      mimetype: 'audio/mp4',
      ptt: true
    }, { quoted: msg });
    const stickerBuffer = fs.readFileSync('./dados/figurinhas/calvo.webp');
    await sock.sendMessage(from, {
      sticker: stickerBuffer
    }, { quoted: msg });
  } catch (e) {
    console.error("Erro no comando calvo", e);
    await sock.sendMessage(from, {
      text: 'TROPA DO CALVO NA PISTAğŸ§‘ğŸ½â€ğŸ¦².'
    }, { quoted: msg });
  }
}

// ===== COMANDO PPK =====
else if (
  isGroup &&
  (
    /^ppk$/i.test(msgLower.trim()) ||
    /^ppk\s+@\d+/i.test(msgLower.trim())   
  )
) {
  try {
    const contextInfo =
      msg.message?.extendedTextMessage?.contextInfo ||
      msg.message?.contextInfo || {};

    const mencionado = Array.isArray(contextInfo.mentionedJid) && contextInfo.mentionedJid.length
      ? contextInfo.mentionedJid[0]
      : null;
    const citado = contextInfo.participant || null;
    const sender = msg.key?.participant || msg.participant || msg.key?.remoteJid || '';

    let alvo = mencionado || citado || sender || '';
    if (typeof alvo !== 'string') alvo = String(alvo || sender || '');
    if (!alvo.includes('@')) {
      alvo = `${alvo}@s.whatsapp.net`;
    } else if (!alvo.endsWith('@s.whatsapp.net') && !alvo.endsWith('@c.us')) {
      alvo = alvo.split('@')[0] + '@s.whatsapp.net';
    }

    if (!alvo || !alvo.includes('@')) {
      return await sock.sendMessage(from, {
        text: 'âŒ NÃ£o consegui identificar o alvo corretamente.',
        quoted: msg
      });
    }

    const numeroAlvo = alvo.split('@')[0];
    const userTag = `@${numeroAlvo}`;

    if (typeof reagir === 'function') {
      setTimeout(() => reagir(from, "ğŸ‘€", msg), 300);
    }

    let msgMedindoPpk = await sock.sendMessage(from, {
      text: `*Medindo a profundidade da ppk de* ${userTag} ğŸ«¸ğŸ«·ğŸ¤”`,
      mentions: [alvo]
    }, { quoted: msg });

    await sleep(1500);
    await sock.sendMessage(from, {
      edit: msgMedindoPpk.key,
      text: `*Medindo a largura da ppk de* ${userTag} ğŸ«¸ğŸ«·ğŸ§`,
      mentions: [alvo]
    });

    await sleep(1500);
    await sock.sendMessage(from, {
      edit: msgMedindoPpk.key,
      text: `*Espera aÃ­ que tÃ´ analisandoğŸ«¦* ${userTag} ğŸ«¸ ğŸ«· ğŸ¤”`,
      mentions: [alvo]
    });

    await sleep(1500);
    const tamanhoPpk = Math.floor(Math.random() * 48) + 1;

    const resultados = [
      {
        faixa: t => t <= 10,
        legenda: t => `*Apertadinha demais...*\nâ‡’ ${userTag}\nProfundidade: âœ®${t}cmâœ®\nCabe nem um cotonete ğŸ˜‚`,
        imagem: "https://files.catbox.moe/cr3ujg.jpg"
      },
      {
        faixa: t => t > 10 && t <= 30,
        legenda: t => `*Tamanho perfeito...*\nâ‡’ ${userTag}\nProfundidade: âœ®${t}cmâœ®\nIdeal pra maldade kkkkk ğŸ‘€`,
        imagem: "https://files.catbox.moe/17fxj6.jpg"
      },
      {
        faixa: t => t > 30 && t < 45,
        legenda: t => `*Eitaaaa!!*\nâ‡’ ${userTag}\nProfundidade: âœ®${t}cmâœ®\nAbismo detectado ğŸ˜‚ğŸ‘ï¸ğŸ‘„ğŸ‘ï¸`,
        imagem: "https://files.catbox.moe/e7ak3h.jpg"
      },
      {
        faixa: t => t >= 45,
        legenda: t => `*QUE ISSO CAVERNA??*\nâ‡’ ${userTag}\nProfundidade absurda: âœ®${t}cmâœ®\nO famoso POCOTÃ“ ğŸ´`,
        video: "https://files.catbox.moe/4cesyx.mp4"
      }
    ];

    const resultado = resultados.find(r => r.faixa(tamanhoPpk));
    const legendaPpk = resultado.legenda(tamanhoPpk);

    if (resultado.video) {
      await sock.sendMessage(from, {
        video: { url: resultado.video },
        caption: legendaPpk,
        mentions: [alvo],
        mimetype: 'video/mp4',
        gifPlayback: true
      }, { quoted: msg });
    } else if (resultado.imagem) {
      const imageBuffer = await axios.get(resultado.imagem, { responseType: 'arraybuffer' }).then(res => res.data);
      await sock.sendMessage(from, {
        image: imageBuffer,
        caption: legendaPpk,
        mentions: [alvo]
      }, { quoted: msg });
    } else {
      await sock.sendMessage(from, {
        text: legendaPpk,
        mentions: [alvo]
      }, { quoted: msg });
    }
  } catch (err) {
    console.error('Erro no comando ppk:', err);
    await sock.sendMessage(from, {
      text: 'âŒ Ocorreu um erro ao processar o comando. Tenta de novo.',
      quoted: msg
    });
  }
}

// ===== COMANDO LINDO/LINDA COM URL =====
else if (
  isGroup &&
  (
    /^lindo$/i.test(msgLower.trim()) || /^linda$/i.test(msgLower.trim()) ||   // sÃ³ "lindo" ou "linda"
    /^lindo\s+@\d+/i.test(msgLower.trim()) || /^linda\s+@\d+/i.test(msgLower.trim()) // com menÃ§Ã£o
  )
) {
  try {
    const contextInfo =
      msg.message?.extendedTextMessage?.contextInfo ||
      msg.message?.contextInfo || {};

    const mencionado = Array.isArray(contextInfo.mentionedJid) && contextInfo.mentionedJid.length
      ? contextInfo.mentionedJid[0]
      : null;
    const citado = contextInfo.participant || null;
    const sender = msg.key?.participant || msg.participant || msg.key?.remoteJid || '';

    // alvo = mencionado OU citado OU quem mandou a msg
    let alvo = mencionado || citado || sender || '';
    if (typeof alvo !== 'string') alvo = String(alvo || sender || '');
    if (!alvo.includes('@')) {
      alvo = `${alvo}@s.whatsapp.net`;
    } else if (!alvo.endsWith('@s.whatsapp.net') && !alvo.endsWith('@c.us')) {
      alvo = alvo.split('@')[0] + '@s.whatsapp.net';
    }

    if (!alvo || !alvo.includes('@')) {
      return await sock.sendMessage(from, {
        text: 'âŒ NÃ£o consegui identificar o alvo corretamente.',
        quoted: msg
      });
    }

    const numeroAlvo = alvo.split('@')[0];
    const userTag = `@${numeroAlvo}`;

    // reaÃ§Ã£o
    if (typeof reagir === 'function') {
      setTimeout(() => reagir(from, "ğŸ˜", msg), 300);
    }

    // suspense igual pau/ppk
    let msgMedindo = await sock.sendMessage(from, {
      text: `*Calculando o quÃ£o lindo(a) Ã©* ${userTag} ğŸ˜`,
      mentions: [alvo]
    }, { quoted: msg });

    await sleep(1500);
    await sock.sendMessage(from, {
      edit: msgMedindo.key,
      text: `*Quase pronto...* ${userTag} ğŸ«£`,
      mentions: [alvo]
    });

    await sleep(1500);
    await sock.sendMessage(from, {
      edit: msgMedindo.key,
      text: `*SÃ³ mais um segundo...* ${userTag} ğŸ˜`,
      mentions: [alvo]
    });

    // porcentagem aleatÃ³ria
    const porcentagem = Math.floor(Math.random() * 100) + 1;

    // define se Ã© "linda" ou "lindo"
    const genero = /^linda/i.test(msgLower.trim()) ? 'f' : 'm';

    const frases = genero === 'f' ? [
      "*Nem o espelho acredita ğŸ˜¬*",
      "*MamÃ£e te ama... sÃ³ ela mesmo ğŸ¥²*",
      "*Um encanto... bem escondido ğŸ¦„*",
      "*Filtro salva viu? ğŸ¤­*",
      "*SÃ³ precisa de uma boa iluminaÃ§Ã£o ğŸ’¡*",
      "*Linda atÃ© demais! ğŸ˜*",
      "*Capa de revista ğŸ’„*",
      "*Rouba olhares por onde passa ğŸ‘€*",
      "*Deusa grega? Com certeza! ğŸ›ï¸*",
      "*Beleza nÃ­vel sobrenatural ğŸ˜µâ€â¤ï¸â€ğŸ’‹â€ğŸ˜µ*"
    ] : [
      "*Nem espelho te reconhece ğŸ˜¬*",
      "*SÃ³ a mÃ£e acha bonito ğŸ¥²*",
      "*Um charmeâ€¦ de outro planeta ğŸª*",
      "*Melhora com filtro ğŸ¤­*",
      "*Um sorriso jÃ¡ ajuda ğŸ˜*",
      "*Bonito atÃ© demais ğŸ˜*",
      "*Carinha de novela ğŸ’…*",
      "*VocÃª para o trÃ¢nsito ğŸ˜*",
      "*Modelo? Com certeza! ğŸ“¸*",
      "*Perfeito demais, socorro! ğŸ˜µâ€ğŸ’«*"
    ];

    const faixa = Math.floor((porcentagem - 1) / 10);
    const fraseEscolhida = frases[faixa];

    // URL das imagens
    const imagemURL = genero === 'f'
      ? 'https://files.catbox.moe/34r9ef.jpg'
      : 'https://files.catbox.moe/54pm4j.jpg';

    // busca imagem via axios
    const imageBuffer = await axios.get(imagemURL, { responseType: 'arraybuffer' }).then(res => res.data);

    const mensagem = `âœ¨ ${userTag} Ã© *${porcentagem}% ${genero === 'f' ? 'linda' : 'lindo'}!*\n${fraseEscolhida}`;

    await sock.sendMessage(from, {
      image: imageBuffer,
      caption: mensagem,
      mentions: [alvo]
    }, { quoted: msg });

  } catch (err) {
    console.error('Erro no comando lindo/linda:', err);
    await sock.sendMessage(from, {
      text: 'âŒ Ocorreu um erro ao processar o comando. Tenta de novo.',
      quoted: msg
    });
  }
}

else if (
  isGroup &&
  (
    /^pau$/i.test(msgLower.trim()) ||                // sÃ³ "pau"
    /^pau\s+@\d+/i.test(msgLower.trim())             // "pau @fulano"
  )
) {
  try {
    const contextInfo =
      msg.message?.extendedTextMessage?.contextInfo ||
      msg.message?.contextInfo || {};

    const mencionado = Array.isArray(contextInfo.mentionedJid) && contextInfo.mentionedJid.length
      ? contextInfo.mentionedJid[0]
      : null;
    const citado = contextInfo.participant || null;
    const sender = msg.key?.participant || msg.participant || msg.key?.remoteJid || '';

    let alvo = mencionado || citado || sender || '';
    if (typeof alvo !== 'string') alvo = String(alvo || sender || '');
    if (!alvo.includes('@')) {
      alvo = `${alvo}@s.whatsapp.net`;
    } else if (!alvo.endsWith('@s.whatsapp.net') && !alvo.endsWith('@c.us')) {
      alvo = alvo.split('@')[0] + '@s.whatsapp.net';
    }

    if (!alvo || !alvo.includes('@')) {
      return await sock.sendMessage(from, {
        text: 'âŒ NÃ£o consegui identificar o alvo corretamente.',
        quoted: msg
      });
    }

    const numeroAlvo = alvo.split('@')[0];
    const userTag = `@${numeroAlvo}`;

    if (typeof reagir === 'function') {
      setTimeout(() => reagir(from, "ğŸ˜³", msg), 300);
    }

    let msgMedindoPau = await sock.sendMessage(from, {
      text: `*Medindo o tamanho do pau de* ${userTag} ğŸ«¸ğŸ«·ğŸ¤”`,
      mentions: [alvo]
    }, { quoted: msg });

    await sleep(1500);
    await sock.sendMessage(from, {
      edit: msgMedindoPau.key,
      text: `*Medindo a grossura do pau de* ${userTag} ğŸ«¸ğŸ«·ğŸ§`,
      mentions: [alvo]
    });

    await sleep(1500);
    await sock.sendMessage(from, {
      edit: msgMedindoPau.key,
      text: `*Espera aÃ­ que tÃ´ medindoğŸ«¦* ${userTag} ğŸ«¸ ğŸ«· ğŸ¤”`,
      mentions: [alvo]
    });

    await sleep(1500);
    const tamanhopau = Math.floor(Math.random() * 30) + 1;

    const resultados = [
      {
        faixa: t => t <= 5,
        legenda: t => `*Kkkkk que dÃ³*\nâ‡’ ${userTag}\nSeu pau mede sÃ³ âœ®${t}cmâœ®\nChama o urologista kkk`,
        video: "https://files.catbox.moe/9eo8hd.mp4"
      },
      {
        faixa: t => t > 5 && t <= 14,
        legenda: t => `*Rapaz...*\nâ‡’ ${userTag}\nSeu pau tem âœ®${t}cmâœ®\nTÃ¡ na mÃ©dia hein`,
        imagem: "https://files.catbox.moe/3snqji.jpg"
      },
      {
        faixa: t => t > 14 && t <= 24,
        legenda: t => `*Meu Deus do cÃ©u...*\nâ‡’ ${userTag}\nSeu pau tem âœ®${t}cmâœ®\nDesumilde demais!!!`,
        imagem: "https://i.postimg.cc/y6cVCDDL/20250706-151303.jpg"
      },
      {
        faixa: t => t >= 25,
        legenda: t => `*QUE ISSO MONSTRO??*\nâ‡’ ${userTag}\nSeu pau tem absurdos âœ®${t}cmâœ®\nIsso nem Ã© humano mais kkkk`,
        imagem: "https://files.catbox.moe/7i4u1l.png"
      }
    ];

    const resultado = resultados.find(r => r.faixa(tamanhopau));
    const legendaPau = resultado.legenda(tamanhopau);

    if (resultado.video) {
      await sock.sendMessage(from, {
        video: { url: resultado.video },
        caption: legendaPau,
        mentions: [alvo],
        mimetype: 'video/mp4',
        gifPlayback: true
      }, { quoted: msg });
    } else if (resultado.imagem) {
      const imageBuffer = await axios.get(resultado.imagem, { responseType: 'arraybuffer' }).then(res => res.data);
      await sock.sendMessage(from, {
        image: imageBuffer,
        caption: legendaPau,
        mentions: [alvo]
      }, { quoted: msg });
    } else {
      await sock.sendMessage(from, {
        text: legendaPau,
        mentions: [alvo]
      }, { quoted: msg });
    }
  } catch (err) {
    console.error('Erro no comando pau:', err);
    await sock.sendMessage(from, {
      text: 'âŒ Ocorreu um erro ao processar o comando. Tenta de novo.',
      quoted: msg
    });
  }
}

// ===== COMANDO GAY =====
else if (
  isGroup &&
  (
    /^gay$/i.test(msgLower.trim()) ||             // sÃ³ "gay"
    /^gay\s+@\d+/i.test(msgLower.trim())         // "gay @fulano"
  )
) {
  try {
    const contextInfo =
      msg.message?.extendedTextMessage?.contextInfo ||
      msg.message?.contextInfo || {};

    const mencionado = Array.isArray(contextInfo.mentionedJid) && contextInfo.mentionedJid.length
      ? contextInfo.mentionedJid[0]
      : null;
    const citado = contextInfo.participant || null;
    const sender = msg.key?.participant || msg.participant || msg.key?.remoteJid || '';

    // alvo = mencionado OU citado OU quem mandou a msg
    let alvo = mencionado || citado || sender || '';
    if (typeof alvo !== 'string') alvo = String(alvo || sender || '');
    if (!alvo.includes('@')) {
      alvo = `${alvo}@s.whatsapp.net`;
    } else if (!alvo.endsWith('@s.whatsapp.net') && !alvo.endsWith('@c.us')) {
      alvo = alvo.split('@')[0] + '@s.whatsapp.net';
    }

    // nÃ£o responde se alvo for o prÃ³prio bot
    if (alvo === sock.user.id) return;

    const numeroAlvo = alvo.split('@')[0];
    const userTag = `@${numeroAlvo}`;

    // reaÃ§Ã£o
    if (typeof reagir === 'function') {
      setTimeout(() => reagir(from, "ğŸŒˆ", msg), 300);
    }

    // suspense inicial igual pau/ppk/lindo
    let msgMedindo = await sock.sendMessage(from, {
      text: `*Calculando o nÃ­vel de gayzice de* ${userTag} ğŸŒˆ`,
      mentions: [alvo]
    }, { quoted: msg });

    await sleep(1500);
    await sock.sendMessage(from, {
      edit: msgMedindo.key,
      text: `*Quase pronto...* ${userTag} ğŸ«£`,
      mentions: [alvo]
    });

    await sleep(1500);
    await sock.sendMessage(from, {
      edit: msgMedindo.key,
      text: `*SÃ³ mais um segundo...* ${userTag} ğŸ˜`,
      mentions: [alvo]
    });

    // porcentagem aleatÃ³ria
    const porcentagem = Math.floor(Math.random() * 200) + 1;

    let frase = '';
    if (porcentagem <= 10) frase = `ğŸ˜‡ ${userTag} nÃ£o Ã© nem um pouco gay.`;
    else if (porcentagem <= 20) frase = `ğŸ¤ ${userTag} tem um leve toque de gay.`;
    else if (porcentagem <= 30) frase = `ğŸ«£ ${userTag} tÃ¡ escondendo alguma coisa aÃ­ hein.`;
    else if (porcentagem <= 40) frase = `ğŸ‘€ ${userTag} gosta de umas coisas diferentes...`;
    else if (porcentagem <= 50) frase = `ğŸ˜ ${userTag} jÃ¡ pensou em experimentar...`;
    else if (porcentagem <= 60) frase = `ğŸŒˆ ${userTag} tÃ¡ no caminho certo...`;
    else if (porcentagem <= 70) frase = `ğŸ’… ${userTag} pinta a unha escondido.`;
    else if (porcentagem <= 80) frase = `ğŸ¥µ ${userTag} sÃ³ falta sair do armÃ¡rio.`;
    else if (porcentagem <= 90) frase = `ğŸ”¥ ${userTag} tÃ¡ quase beijando o amiguinho.`;
    else if (porcentagem <= 100) frase = `ğŸ³ï¸â€ğŸŒˆ ${userTag} Ã© gay com orgulho!`;
    else if (porcentagem <= 120) frase = `ğŸ’– ${userTag} Ã© ultra gay, sem freio.`;
    else if (porcentagem <= 140) frase = `ğŸ› ${userTag} beija macho na voadora.`;
    else if (porcentagem <= 160) frase = `ğŸš¨ ${userTag} tÃ¡ na lista dos gays mais ativos do Brasil.`;
    else if (porcentagem <= 180) frase = `ğŸ’¥ ${userTag} Ã© tÃ£o gay que virou referÃªncia.`;
    else frase = `ğŸ‘‘ ${userTag} Ã© o imperador supremo do arco-Ã­ris! 200% GAY kkkkkk`;

    await sock.sendMessage(from, {
      video: { url: 'https://files.catbox.moe/dsi783.mp4' },
      caption: `${frase}\n\n*Porcentagem gay:* ${porcentagem}%`,
      gifPlayback: true,
      mentions: [alvo]
    }, { quoted: msg });

  } catch (err) {
    console.error('Erro no comando gay:', err);
    await sock.sendMessage(from, {
      text: 'âŒ Ocorreu um erro ao processar o comando. Tenta de novo.',
      quoted: msg
    });
  }
}

// ===== COMANDO CORNO =====
else if (
  isGroup &&
  (
    /^corno$/i.test(msgLower.trim()) ||            // sÃ³ "corno"
    /^corno\s+@\d+/i.test(msgLower.trim())        // "corno @fulano"
  )
) {
  try {
    const contextInfo =
      msg.message?.extendedTextMessage?.contextInfo ||
      msg.message?.contextInfo || {};

    const mencionado = Array.isArray(contextInfo.mentionedJid) && contextInfo.mentionedJid.length
      ? contextInfo.mentionedJid[0]
      : null;
    const citado = contextInfo.participant || null;
    const sender = msg.key?.participant || msg.participant || msg.key?.remoteJid || '';

    // alvo = mencionado OU citado OU quem mandou a msg
    let alvo = mencionado || citado || sender || '';
    if (typeof alvo !== 'string') alvo = String(alvo || sender || '');
    if (!alvo.includes('@')) {
      alvo = `${alvo}@s.whatsapp.net`;
    } else if (!alvo.endsWith('@s.whatsapp.net') && !alvo.endsWith('@c.us')) {
      alvo = alvo.split('@')[0] + '@s.whatsapp.net';
    }

    // nÃ£o responde se alvo for o prÃ³prio bot
    if (alvo === sock.user.id) return;

    const numeroAlvo = alvo.split('@')[0];
    const userTag = `@${numeroAlvo}`;

    // reaÃ§Ã£o
    if (typeof reagir === 'function') {
      setTimeout(() => reagir(from, "ğŸ‚", msg), 300);
    }

    // suspense inicial
    let msgMedindo = await sock.sendMessage(from, {
      text: `*Calculando o nÃ­vel de corno de* ${userTag} ğŸ‚`,
      mentions: [alvo]
    }, { quoted: msg });

    await sleep(1500);
    await sock.sendMessage(from, {
      edit: msgMedindo.key,
      text: `*Quase pronto...* ${userTag} ğŸ¤”`,
      mentions: [alvo]
    });

    await sleep(1500);
    await sock.sendMessage(from, {
      edit: msgMedindo.key,
      text: `*SÃ³ mais um segundo...* ${userTag} ğŸ˜‚`,
      mentions: [alvo]
    });

    // porcentagem aleatÃ³ria
    const porcentagem = Math.floor(Math.random() * 101);
    let frase = porcentagem === 0
      ? `ğŸ˜‡ ${userTag} nÃ£o Ã© corno! Porcentagem: 0% ğŸ™`
      : `ğŸ¤£ ${userTag} Ã© ${porcentagem}% corno kkkkkkk`;

    // envia vÃ­deo direto via URL
    await sock.sendMessage(from, {
      video: { url: 'https://files.catbox.moe/md7drc.mp4' },
      mimetype: 'video/mp4',
      caption: frase,
      mentions: [alvo],
      gifPlayback: true
    }, { quoted: msg });

  } catch (err) {
    console.error('Erro no comando corno:', err);
    await sock.sendMessage(from, {
      text: 'âŒ Ocorreu um erro ao processar o comando. Tenta de novo.',
      quoted: msg
    });
  }
}

// ===== COMANDO SAFADA =====
else if (
  isGroup &&
  (
    /^safada$/i.test(msgLower.trim()) ||            // sÃ³ "safada"
    /^safada\s+@\d+/i.test(msgLower.trim())        // "safada @fulano"
  )
) {
  try {
    const contextInfo =
      msg.message?.extendedTextMessage?.contextInfo ||
      msg.message?.contextInfo || {};

    const mencionado = Array.isArray(contextInfo.mentionedJid) && contextInfo.mentionedJid.length
      ? contextInfo.mentionedJid[0]
      : null;
    const citado = contextInfo.participant || null;
    const sender = msg.key?.participant || msg.participant || msg.key?.remoteJid || '';

    // alvo = mencionado OU citado OU quem mandou a msg
    let alvo = mencionado || citado || sender || '';
    if (typeof alvo !== 'string') alvo = String(alvo || sender || '');
    if (!alvo.includes('@')) {
      alvo = `${alvo}@s.whatsapp.net`;
    } else if (!alvo.endsWith('@s.whatsapp.net') && !alvo.endsWith('@c.us')) {
      alvo = alvo.split('@')[0] + '@s.whatsapp.net';
    }

    // nÃ£o responde se alvo for o prÃ³prio bot
    if (alvo === sock.user.id) return;

    const numeroAlvo = alvo.split('@')[0];
    const userTag = `@${numeroAlvo}`;

    // reaÃ§Ã£o inicial
    if (typeof reagir === 'function') {
      setTimeout(() => reagir(from, "ğŸ”¥", msg), 300);
    }

    // suspense inicial
    let msgMedindo = await sock.sendMessage(from, {
      text: `*Calculando o nÃ­vel de safadeza de* ${userTag} ğŸ”¥`,
      mentions: [alvo]
    }, { quoted: msg });

    await sleep(1500);
    await sock.sendMessage(from, {
      edit: msgMedindo.key,
      text: `*Quase pronto...* ${userTag} ğŸ¤­`,
      mentions: [alvo]
    });

    await sleep(1500);
    await sock.sendMessage(from, {
      edit: msgMedindo.key,
      text: `*SÃ³ mais um segundo...* ${userTag} ğŸ˜³`,
      mentions: [alvo]
    });

    // porcentagem aleatÃ³ria
    const porcentagem = Math.floor(Math.random() * 100) + 1;

    // define vÃ­deo de acordo com a porcentagem
    let videoUrl = '';
    if (porcentagem <= 19) videoUrl = 'https://files.catbox.moe/5zq4f6.mp4';
    else if (porcentagem <= 29) videoUrl = 'https://files.catbox.moe/kjkg3k.mp4';
    else if (porcentagem <= 49) videoUrl = 'https://files.catbox.moe/4hqawv.mp4';
    else if (porcentagem <= 59) videoUrl = 'https://files.catbox.moe/104he2.mp4';
    else if (porcentagem <= 70) videoUrl = 'https://files.catbox.moe/hb4leh.mp4';
    else videoUrl = 'https://files.catbox.moe/b3t11v.mp4';

    // envia resultado final
    await sock.sendMessage(from, {
      video: { url: videoUrl },
      caption: `ğŸ” O nÃ­vel de *safadeza* de ${userTag} Ã© de *${porcentagem}%*! ğŸ˜³ğŸ”¥`,
      gifPlayback: true,
      mentions: [alvo]
    }, { quoted: msg });

  } catch (err) {
    console.error('Erro no comando safada:', err);
    await sock.sendMessage(from, {
      text: 'âŒ Ocorreu um erro ao processar o comando. Tenta de novo.',
      quoted: msg
    });
  }
}

else if (msgLower === 'sorteio' && isGroup) {
  if (global.sorteioAtivo?.[from]) {
    await sock.sendMessage(from, { text: 'âš ï¸ Um sorteio jÃ¡ estÃ¡ em andamento.' }, { quoted: msg });
    return;
  }
  global.sorteioAtivo = global.sorteioAtivo || {};
  global.sorteioParticipantes = global.sorteioParticipantes || {};
  global.sorteioAtivo[from] = true;
  global.sorteioParticipantes[from] = [];
  const participantes = global.sorteioParticipantes[from];
  const metadata = await sock.groupMetadata(from);
  const groupMembers = metadata.participants;
  const allJids = groupMembers.map(m => m.id);
  const textoInicial = `ğŸ‰ *SORTEIO INICIADO!*\n\nMande "eu" no chat pra participar!\nâ³ VocÃª tem *1 MINUTO* para entrar!`;
  const msgSorteio = await sock.sendMessage(from, {
    text: textoInicial,
    mentions: allJids
  }, { quoted: msg });
  const listener = async (update) => {
    if (!global.sorteioAtivo[from]) return;
    if (update.type !== 'notify') return;
    const messages = update.messages;
    if (!messages || messages.length === 0) return;
    const uMsg = messages[0];
    if (!uMsg.message || !uMsg.key || !uMsg.key.remoteJid) return;
    if (uMsg.key.remoteJid !== from) return;
    let uText = '';
    if (uMsg.message.conversation) uText = uMsg.message.conversation.toLowerCase();
    else if (uMsg.message.extendedTextMessage?.text) 
      uText = uMsg.message.extendedTextMessage.text.toLowerCase();
    else return;
    const uSender = uMsg.key.participant || uMsg.key.remoteJid;
    if (uText === 'eu' && !participantes.includes(uSender)) {
      participantes.push(uSender);
      await sock.sendMessage(from, {
        text: `âœ… @${uSender.split('@')[0]} entrou no sorteio!`,
        mentions: [uSender]
      });
    }
  };
  sock.ev.on('messages.upsert', listener);
  setTimeout(async () => {
    global.sorteioAtivo[from] = false;
    sock.ev.off('messages.upsert', listener);
    if (participantes.length === 0) {
      await sock.sendMessage(from, { text: 'âŒ NinguÃ©m participou do sorteio.' });
      return;
    }
    let msgContagem = await sock.sendMessage(from, {
      text: 'â³ InscriÃ§Ãµes encerradas! Sorteio comeÃ§a em 10 segundos...'
    });
    for (let i = 10; i >= 1; i--) {
      await new Promise(r => setTimeout(r, 1000));
      await sock.sendMessage(from, {
        text: ` _Sorteando em:_ *${i}*...`,
        edit: msgContagem.key
      });
    }
    const sorteado = participantes[Math.floor(Math.random() * participantes.length)];
    await sock.sendMessage(from, {
      text: `ğŸ¥³ PARABÃ‰NS @${sorteado.split('@')[0]}!\n\nğŸ VocÃª foi o *SORTEADO*!`,
      mentions: [sorteado]
    });
    global.sorteioParticipantes[from] = [];
  }, 60000);
}

else if (isGroup && ['namorar', 'terminar', 'dupla'].some(c => msgLower.startsWith(c))) {
await sock.sendMessage(from, {
    react: {
      text: "ğŸ’•",
      key: msg.key
    }
  });
  await handleNamorar(sock, msg, msgLower);
}

else if (isGroup && /^([#])?(beijo|beijar|bj)\b/i.test(msgLower)) {
await sock.sendMessage(from, {
    react: {
      text: "â¤ï¸",
      key: msg.key
    }
  });
  const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant || null;
  const mentionedJid = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
  const target = quotedParticipant ? quotedParticipant : (mentionedJid.length > 0 ? mentionedJid[0] : null);
  const senderJid = typeof sender === 'string' ? sender : msg.key.participant || msg.participant || '';
  const senderNumber = senderJid.replace(/[^0-9]/g, '');
  const senderMention = `@${senderNumber}`;
  let targetMention = null;
  if (target) {
    const targetNumber = target.replace(/[^0-9]/g, '');
    targetMention = `@${targetNumber}`;
  }
  if (!targetMention) {
    await sock.sendMessage(from, {
      text: 'ğŸ˜— Marque ou responda alguÃ©m que vocÃª quer beijar.',
    }, { quoted: msg });
    return;
  }
  const texto = `ğŸ’‹ğŸŒ¹ ${senderMention} tascou um beijo cinematogrÃ¡fico em ${targetMention}! A paixÃ£o estÃ¡ no ar! â¤ï¸â€ğŸ”¥ğŸ’•ğŸ‘ï¸ğŸ«¦ğŸ‘ï¸`;
  const videos = [
    'https://files.catbox.moe/wyrrby.mp4',
    'https://files.catbox.moe/b79cpy.mp4'
  ];
  const randomVideo = videos[Math.floor(Math.random() * videos.length)];
  try {
    await sock.sendMessage(from, {
      video: { url: randomVideo },
      caption: texto,
      gifPlayback: true,
      mentions: [senderJid, target],
    }, { quoted: msg });
    await sock.sendMessage(from, {
  audio: { url: 'https://files.catbox.moe/ayghjg.mp3' },
  mimetype: 'audio/mp4',
  ptt: true
}, { quoted: msg });
  } catch (e) {
    console.error("Erro no comando beijo:", e);
    await sock.sendMessage(from, {
      text: 'âŒ Ocorreu um erro ao tentar enviar o beijo.'
    }, { quoted: msg });
  }
}

else if (isGroup && /^tapa\b/i.test(msgLower)) {
  const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant || null;
  const mentionedJid = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
  const groupMetadata = isGroup ? await sock.groupMetadata(from) : {};
  const participantes = groupMetadata?.participants || [];
  const target = quotedParticipant || (mentionedJid.length > 0 ? mentionedJid[0] : sender);
  const userTag = `@${target.split('@')[0]}`;
  await sock.sendMessage(from, {
    react: {
      text: "ğŸ‘",
      key: msg.key
    }
  });
  const tapaUrls = {
    1: 'https://files.catbox.moe/0ecjnw.mp4',
    2: 'https://files.catbox.moe/0oyb7a.mp4',
    3: 'https://files.catbox.moe/0oyb7a.mp4',
    4: 'https://files.catbox.moe/k8c00z.mp4',
    5: 'https://files.catbox.moe/bxbefq.mp4',
    6: 'https://files.catbox.moe/84llaw.mp4',
    7: 'https://files.catbox.moe/oiqia5.mp4',
    8: 'https://files.catbox.moe/vxbktv.mp4'
  };
  const rand = Math.floor(Math.random() * 8) + 1;
  const videoUrl = tapaUrls[rand];
  let caption = `ğŸ‘‹ *${userTag}, vocÃª levou um tapa!*`;
  let mentions = [target];
  if (rand === 4 && participantes.length > 2) {
    const outros = participantes
      .filter(p => p.id !== target && p.id !== sender);
    if (outros.length > 0) {
      const aleatorio = outros[Math.floor(Math.random() * outros.length)];
      const erroTag = `@${aleatorio.id.split('@')[0]}`;
      caption = `ğŸ˜… Vix... tentou dar um tapa em ${userTag}, mas acabou acertando ${erroTag} sem querer kkk`;
      mentions = [target, aleatorio.id];
    }
  }
  await sock.sendMessage(from, {
    video: { url: videoUrl },
    caption,
    gifPlayback: true,
    mentions
  }, { quoted: msg });
}

else if (isGroup && /^([#])?(lavarlouÃ§a|lavarlouca)\b/i.test(msgLower)) {
  try {
    const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant || null;
    const mentionedJid = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
    const target = quotedParticipant ? quotedParticipant : (mentionedJid.length > 0 ? mentionedJid[0] : null);

    const senderJid = typeof sender === 'string' ? sender : msg.key.participant || msg.participant || '';
    const senderNumber = senderJid.replace(/[^0-9]/g, '');
    const senderMention = `@${senderNumber}`;

    let targetMention = null;
    let targetNumber = null;
    if (target) {
      targetNumber = target.replace(/[^0-9]/g, '');
      targetMention = `@${targetNumber}`;
    }

    if (!targetMention) {
      await sock.sendMessage(from, {
        text: 'ğŸ½ï¸ Marque ou responda alguÃ©m para lavar a louÃ§a!',
      }, { quoted: msg });
      return;
    }

    await sock.sendMessage(from, {
      react: { text: "ğŸ§½", key: msg.key }
    });

    const frases = [
      'NÃ£o adianta correr, a pia te espera! ğŸ˜‚',
      'Coragem, campeÃ£o... a louÃ§a nÃ£o se lava sozinha! ğŸ½ï¸',
      'Mais sujo que essa louÃ§a sÃ³ suas desculpas! ğŸ«§',
      'Lava aÃ­ rapidinho e volta pro grupo! ğŸ’¦',
      'A louÃ§a nÃ£o vai se lavar sozinha, amigÃ£o! ğŸ§¼',
      'MissÃ£o dada Ã© missÃ£o cumprida! ğŸ§½',
      'Vai lÃ¡ mostrar que sabe esfregar um prato! ğŸ›',
      'Seu nome foi sorteado pra lavar hoje! ğŸ¯',
      'O grupo inteiro agradece seu esforÃ§o na pia! ğŸ™Œ'
    ];

    const fraseAleatoria = frases[Math.floor(Math.random() * frases.length)];
    const texto = `ğŸ§¼ğŸ½ï¸ ${senderMention} mandou ${targetMention} lavar a louÃ§a!\n${fraseAleatoria}`;

    const videoBuffer = await axios.get('https://files.catbox.moe/879o7q.mp4', {
  responseType: 'arraybuffer'
}).then(res => res.data);
    await sock.sendMessage(from, {
      video: videoBuffer,
      caption: texto,
      gifPlayback: true,
      mentions: [senderJid, target]
    }, { quoted: msg });
  } catch (err) {
    console.error('Erro no comando tapa:', err);
    await sock.sendMessage(from, {
      text: 'âŒ Ocorreu um erro ao tentar enviar o vÃ­deo.'
    }, { quoted: msg });
  }
}

else if (isGroup && /^([#])?tapao\b/i.test(msgLower)) {
  const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant || null;
  const mentionedJid = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
  const target = quotedParticipant ? quotedParticipant : (mentionedJid.length > 0 ? mentionedJid[0] : null);

  const senderJid = typeof sender === 'string' ? sender : msg.key.participant || msg.participant || '';
  const senderNumber = senderJid.replace(/[^0-9]/g, '');
  const senderMention = `@${senderNumber}`;

  if (!target) {
    await sock.sendMessage(from, {
      text: 'ğŸ–ï¸ Marque alguÃ©m pra levar um tapÃ£o!',
    }, { quoted: msg });
    return;
  }

  const targetNumber = target.replace(/[^0-9]/g, '');
  const targetMention = `@${targetNumber}`;

  await sock.sendMessage(from, {
    react: { text: "ğŸ‘", key: msg.key }
  });

  const frases = [
    'Tomou um tapÃ£o que atÃ© girou! ğŸ˜‚',
    'Isso aqui foi pra aprender a nÃ£o falar besteira! ğŸ«¢',
    'PlÃ¡Ã¡Ã¡! Ouvi daqui! ğŸ˜‚',
    'Agora acorda, que esse tapa foi de realidade! ğŸ’¢',
    'Quem mandou vacilar? TapÃ£o neles! ğŸ’¥',
    'Foi de mÃ£o aberta, sem dÃ³ nem piedade! ğŸ˜¤',
    'A bochecha tÃ¡ atÃ© vermelha agora! ğŸ˜³',
    'Avisa quando quiser outro! ğŸ‘‹',
    'Reage aÃ­ depois dessa! ğŸ”¥'
  ];
  const fraseAleatoria = frases[Math.floor(Math.random() * frases.length)];
  const texto = `ğŸ’¢ğŸ”¥ ${senderMention} *deu um tapÃ£o em* ${targetMention}!\n${fraseAleatoria}`;

  try {
const videoBuffer = await axios.get('https://files.catbox.moe/sqkk59.mp4', {
  responseType: 'arraybuffer'
}).then(res => res.data);
    await sock.sendMessage(from, {
      video: videoBuffer,
      caption: texto,
      gifPlayback: true,
      mentions: [senderJid, target]
    }, { quoted: msg });
  } catch (err) {
    console.error('Erro no comando tapa:', err);
    await sock.sendMessage(from, {
      text: 'âŒ Ocorreu um erro ao tentar enviar o vÃ­deo.'
    }, { quoted: msg });
  }
}

else if (isGroup && /^([#])?(matar|mata)\b/i.test(msgLower)) {
  await sock.sendMessage(from, { react: { text: "ğŸ¤º", key: msg.key } });

  const quotedParticipant = msg.message?.extendedTextMessage?.contextInfo?.participant || null;
  const mentionedJid = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
  const target = quotedParticipant ? quotedParticipant : (mentionedJid.length > 0 ? mentionedJid[0] : null);

  const senderJid = typeof sender === 'string' ? sender : msg.key.participant || msg.participant || '';
  const senderNumber = senderJid.replace(/[^0-9]/g, '');
  const senderMention = `@${senderNumber}`;

  let targetMention = null;
  if (target) {
    const targetNumber = target.replace(/[^0-9]/g, '');
    targetMention = `@${targetNumber}`;
  }

  const texto = targetMention
    ? `ğŸ”ªâš”ï¸ ${senderMention} ğğ¥ğ¢ğ¦ğ¢ğ§ğ¨ğ® ğŸğ«ğ¢ğšğ¦ğğ§ğ­ğ ${targetMention}! â˜ ï¸`
    : `âš”ï¸ ${senderMention} tentou matar o ar... mas nÃ£o acertou ninguÃ©m! ğŸ˜‚`;

  const links = [
    'https://files.catbox.moe/df1teu.mp4',
    'https://files.catbox.moe/ctzmqg.mp4',
    'https://files.catbox.moe/cgeqqw.mp4',
    'https://files.catbox.moe/iyyo7m.mp4',
    'https://files.catbox.moe/0r5aty.mp4'
  ];
  const linkAleatorio = links[Math.floor(Math.random() * links.length)];

  try {
    await sock.sendMessage(from, {
      video: { url: linkAleatorio },
      caption: texto,
      gifPlayback: true,
      mentions: target ? [senderJid, target] : [senderJid],
    }, { quoted: msg });
  } catch (e) {
    console.error("Erro no comando matar:", e);
    await sock.sendMessage(from, {
      text: 'âŒ Ocorreu um erro ao tentar executar o comando matar.'
    }, { quoted: msg });
  }
}

else if (isGroup && msgLower === 'rankgay') {
   try {
    const groupMetadata = await getGroupMetadataCached(from, sock);
    const participantes = groupMetadata.participants.filter(p => !p.id.includes('g.us'));
 try {
    await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
  } catch {}
    if (participantes.length < 5) {
      await sock.sendMessage(from, { text: 'âŒ O grupo precisa ter pelo menos 5 membros para gerar o rank gay.' }, { quoted: msg });
      return;
    }
    const sorteados = participantes
      .sort(() => Math.random() - 0.5)
      .slice(0, 5);
    const frasesZoeira = (porc) => {
      if (porc >= 90) return 'ğŸŒˆ Esse aqui jÃ¡ tÃ¡ marchando na Parada Gay com glitter na cara e cropped da Barbie!';
      if (porc >= 75) return 'ğŸ’… Vive de shortinho curto ouvindo Pabllo Vittar no talo.';
      if (porc >= 50) return 'ğŸ˜ JÃ¡ deu uma rebolada pro amigo e gostou.';
      if (porc >= 25) return 'ğŸ¤¨ Fala que Ã© hÃ©tero, mas assiste BBB com crush no Fred.';
      return 'ğŸ§¢ Esse jura que Ã© hÃ©tero, mas passa pano pra cada macho feio...';
    };
    let texto = 'ğŸ³ï¸â€ğŸŒˆ *RANKING GAY OFICIAL DO GRUPO* ğŸ³ï¸â€ğŸŒˆ\n';
    texto += 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n';
    const mentions = [];
    for (const p of sorteados) {
      const porc = Math.floor(Math.random() * 100) + 1;
      const tag = `@${p.id.split('@')[0]}`;
      mentions.push(p.id);
      texto += `ğŸ‘¤ ${tag} â€” *${porc}% GAY*\n_${frasesZoeira(porc)}_\n\n`;
    }
        await sock.sendMessage(from, {
      video: { url: 'https://files.catbox.moe/dsi783.mp4' },
      caption: texto.trim(),
      gifPlayback: true,
      mentions
    }, { quoted: msg });
  } catch (e) {
    console.error('Erro no comando rankgay:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Erro ao gerar o rank gay.',
    }, { quoted: msg });
  }
}
 
else if (isGroup && (msgLower === 'rankppk' || msgLower === 'rankbuceta')) {
  try {
    const groupMetadata = await getGroupMetadataCached(from, sock);
    const participantes = groupMetadata.participants.filter(p => !p.id.includes('g.us'));
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ’•', key: msg.key } });
  } catch {} 
    if (participantes.length < 5) {
      await sock.sendMessage(from, { text: 'âŒ O grupo precisa de pelo menos 5 membros para o ranking da buceta.' }, { quoted: msg });
      return;
    }
    const sorteados = participantes.sort(() => Math.random() - 0.5).slice(0, 5);
    const frasesPpk = (tam) => {
      if (tam <= 5) return 'ğŸ§ƒ Entrou sÃ³ a pontinha e jÃ¡ reclamou de dor ğŸ˜¬';
      if (tam <= 10) return 'ğŸ”’ Apertadinha... sÃ³ entra se pedir licenÃ§a primeiro!';
      if (tam <= 15) return 'ğŸ‘… Cabe o bot, o admin e ainda sobra espaÃ§o pra um milkshake';
      if (tam <= 20) return 'ğŸŒªï¸ JÃ¡ virou parque de diversÃ£o do bairro';
      if (tam <= 30) return 'ğŸš¨ Qualquer coisa que entra ali precisa de resgate';
      return 'ğŸ˜ Isso aÃ­ Ã© o *multiverso da buceta*! JÃ¡ moram 3 famÃ­lias ali dentro';
    };
    let texto = 'ğŸ’¦ *TOP 5 PPKAS DO GRUPOğŸ˜‚* ğŸ’¦\n';
    texto += 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n';
    const mentions = [];
    for (const p of sorteados) {
      const tamanho = Math.floor(Math.random() * 35) + 1;
      const tag = `@${p.id.split('@')[0]}`;
      mentions.push(p.id);
      texto += `ğŸ’‹ ${tag} â€” *${tamanho}cm de PPK*\n_${frasesPpk(tamanho)}_\n\n`;
    }
    await sock.sendMessage(from, {
      video: { url: 'https://files.catbox.moe/1w727h.mp4' },
      caption: texto.trim(),
      gifPlayback: true,
      mentions
    }, { quoted: msg });
  } catch (e) {
    console.error('Erro no comando rankPpk:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Deu erro ao montar o ranking bucetudo.',
    }, { quoted: msg });
  }
}

else if (isGroup && (msgLower === 'rankpau' || msgLower === 'pau')) {
  try {
    const groupMetadata = await getGroupMetadataCached(from, sock);
    const participantes = groupMetadata.participants.filter(p => !p.id.includes('g.us'));
try {
    await sock.sendMessage(from, { react: { text: 'ğŸªµ', key: msg.key } });
  } catch {}
    
    if (participantes.length < 5) {
      await sock.sendMessage(from, { text: 'âŒ O grupo precisa de pelo menos 5 membros para o ranking do PAU.' }, { quoted: msg });
      return;
    }
    const sorteados = participantes.sort(() => Math.random() - 0.5).slice(0, 5);
    const frasesPau = (tam) => {
      if (tam <= 8) return 'ğŸ”Œ VersÃ£o USB... sÃ³ conecta se for com carinho';
      if (tam <= 14) return 'ğŸŒ ClÃ¡ssico nacional, padrÃ£o mÃ©dio';
      if (tam <= 20) return 'ğŸš€ Pau fogueteiro, jÃ¡ foi atÃ© pra NASA';
      if (tam <= 30) return 'ğŸª“ Esse aÃ­ tem CPF prÃ³prio e paga imposto';
      if (tam <= 40) return 'Famoso espanca ÃºterosğŸ˜‚';
      return 'ğŸ² O dragÃ£o acordou, se esconde que Ã© tsunami';
    };
    let texto = 'ğŸ† *TOP 5 PAUZUDOS DO GRUPO* ğŸ†\n';
    texto += 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n';
    const mentions = [];
    for (const p of sorteados) {
      const tamanho = Math.floor(Math.random() * 48) + 1;
      const tag = `@${p.id.split('@')[0]}`;
      mentions.push(p.id);
      texto += `ğŸŒ ${tag} â€” *${tamanho}cm de PAU*\n_${frasesPau(tamanho)}_\n\n`;
    }
    await sock.sendMessage(from, {
      video: { url: 'https://files.catbox.moe/zoiq09.mp4' },
      caption: texto.trim(),
      gifPlayback: true,
      mentions
    }, { quoted: msg });
  } catch (e) {
    console.error('Erro no comando rankpau:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Deu erro ao montar o ranking paududo.',
    }, { quoted: msg });
  }
}

else if (isGroup && (msgLower === 'rankputa' || msgLower === 'puta')) {
  try {
    const groupMetadata = await getGroupMetadataCached(from, sock);
    const participantes = groupMetadata.participants.filter(p => !p.id.includes('g.us'));
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ’…ğŸ»', key: msg.key } });
  } catch {}    
    if (participantes.length < 5) {
      await sock.sendMessage(from, { text: 'âŒ O grupo precisa de pelo menos 5 membros para o ranking da putaria.' }, { quoted: msg });
      return;
    }
    const sorteados = participantes.sort(() => Math.random() - 0.5).slice(0, 5);
    const frasePutaria = (p) => {
      if (p <= 20) return 'ğŸš« Ainda assiste desenho da Barbie';
      if (p <= 40) return 'ğŸ˜‡ SÃ³ manda nude por engano (ou serÃ¡ que nÃ£o?)';
      if (p <= 60) return 'ğŸ”¥ JÃ¡ caiu na tentaÃ§Ã£o algumas vezes...';
      if (p <= 80) return 'ğŸ‘… Boca de 09h Ã s 18h e xereca de plantÃ£o';
      if (p < 100) return 'ğŸ‘ P*ta licenciada pelo MEC';
      return 'ğŸ‘‘ Rainha da putaria. Tem mais currÃ­culo que atriz pornÃ´';
    };
    let texto = 'ğŸ’‹ *TOP 5 MAIS PUTAS DO GRUPO* ğŸ’‹\n';
    texto += 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n';
    const mentions = [];
    for (const p of sorteados) {
      const porcentagem = Math.floor(Math.random() * 100) + 1;
      const tag = `@${p.id.split('@')[0]}`;
      mentions.push(p.id);
      texto += `ğŸ’„ ${tag} â€” *${porcentagem}% puta*\n_${frasePutaria(porcentagem)}_\n\n`;
    }
    await sock.sendMessage(from, {
  video: { url: 'https://files.catbox.moe/87upof.mp4' },
  gifPlayback: true,
  caption: texto.trim(),
  mentions
}, { quoted: msg });

  } catch (e) {
    console.error('Erro no comando rankputa:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Erro ao gerar o ranking das putas.',
    }, { quoted: msg });
  }
}

else if (isGroup && (msgLower === 'rankclt' || msgLower === 'clt')) {
  try {
    const groupMetadata = await getGroupMetadataCached(from, sock);
    const participantes = groupMetadata.participants.filter(p => !p.id.includes('g.us'));
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ‘·ğŸ»â€â™€ï¸', key: msg.key } });
  } catch {}
    if (participantes.length < 5) {
      await sock.sendMessage(from, { text: 'âŒ O grupo precisa de pelo menos 5 membros para o ranking CLT.' }, { quoted: msg });
      return;
    }
    const sorteados = participantes.sort(() => Math.random() - 0.5).slice(0, 5);
    const fraseCLT = (p) => {
      if (p <= 20) return 'ğŸ˜ Trabalha por aplicativo e vive pedindo Pix';
      if (p <= 40) return 'ğŸš¨ JÃ¡ foi demitido por "reduÃ§Ã£o de custos" 3 vezes';
      if (p <= 60) return 'ğŸ“ Tem crachÃ¡ mas o salÃ¡rio mal paga o aluguel';
      if (p <= 80) return 'â˜• Vive de cafÃ© e reuniÃ£o que podia ser um e-mail';
      if (p < 100) return 'ğŸª™ Passa mais tempo no RH do que na prÃ³pria casa kkkk';
      return 'ğŸ‘” CLT raiz: sonha com fÃ©rias, acorda com despertador e vive pelo 13Âº';
    };
    let texto = 'ğŸ—ƒï¸ *TOP 5 MAIS CLT DO GRUPO* ğŸ—ƒï¸\n';
    texto += 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n';
    const mentions = [];
    for (const p of sorteados) {
      const porcentagem = Math.floor(Math.random() * 100) + 1;
      const tag = `@${p.id.split('@')[0]}`;
      mentions.push(p.id);
      texto += `ğŸ§¾ ${tag} â€” *${porcentagem}% CLT*\n_${fraseCLT(porcentagem)}_\n\n`;
    }
await sock.sendMessage(from, {
  video: { url: 'https://files.catbox.moe/241uqa.mp4' },
  gifPlayback: true,
  caption: texto.trim(),
  mentions
}, { quoted: msg });
  } catch (e) {
    console.error('Erro no comando rankclt:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Erro ao gerar o ranking CLT.',
    }, { quoted: msg });
  }
}
 
else if (isGroup && msgLower === 'rankcorno') {
  try {
    const groupMetadata = await getGroupMetadataCached(from, sock);
    const participantes = groupMetadata.participants.filter(p => !p.id.includes('g.us'));
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ‚', key: msg.key } });
  } catch {}
    if (participantes.length < 5) {
      await sock.sendMessage(from, { text: 'âŒ O grupo precisa ter pelo menos 5 membros para gerar o rank corno.' }, { quoted: msg });
      return;
    }
    const sorteados = participantes
      .sort(() => Math.random() - 0.5)
      .slice(0, 5);
    const frasesCornudo = (porc) => {
      if (porc >= 90) return 'ğŸ«  JÃ¡ tÃ¡ criando chifre em casa e chamando de antena 5G.';
      if (porc >= 75) return 'ğŸ˜­ Sabe que Ã© corno e ainda paga o iFood pro RicardÃ£o.';
      if (porc >= 50) return 'ğŸ˜¢ Leva chifre e ainda pede desculpa.';
      if (porc >= 25) return 'ğŸ§ Ouvinte fiel do Pablo do Arrocha... sinal de alerta!';
      return 'ğŸ˜ AtÃ© agora tÃ¡ ileso... mas o RicardÃ£o jÃ¡ mandou solicitaÃ§Ã£o no Insta.';
    };
    let texto = 'ğŸ® *RANKING CORNO OFICIAL DO GRUPO* ğŸ®\n';
    texto += 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n';
    const mentions = [];
    for (const p of sorteados) {
      const porc = Math.floor(Math.random() * 100) + 1;
      const tag = `@${p.id.split('@')[0]}`;
      mentions.push(p.id);
      texto += `ğŸ‘¤ ${tag} â€” *${porc}% CORNO*\n_${frasesCornudo(porc)}_\n\n`;
    }
await sock.sendMessage(from, {
  video: { url: 'https://files.catbox.moe/md7drc.mp4' },
  gifPlayback: true,
  caption: texto.trim(),
  mentions
}, { quoted: msg });
  } catch (e) {
    console.error('Erro no comando rankcorno:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Erro ao gerar o rank corno.',
    }, { quoted: msg });
  }
}

else if (isGroup && (msgLower === 'rankgado' || msgLower === 'rankgados')) {
  try {
    const groupMetadata = await getGroupMetadataCached(from, sock);
    const participantes = groupMetadata.participants.filter(p => !p.id.includes('g.us'));
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ®', key: msg.key } });
  } catch {}
    if (participantes.length < 5) {
      await sock.sendMessage(from, { text: 'âŒ O grupo precisa ter pelo menos 5 membros para gerar o rank gado.' }, { quoted: msg });
      return;
    }
    const sorteados = participantes
      .sort(() => Math.random() - 0.5)
      .slice(0, 5);
    const frasesGado = (porc) => {
      if (porc >= 90) return 'ğŸ„ Aceita atÃ© ser chamado de â€œamiguinhoâ€ por quem ama.';
      if (porc >= 75) return 'ğŸ¤§ Gasta Pix com quem nem visualiza as mensagens.';
      if (porc >= 50) return 'ğŸ«  Sabe que Ã© gado e ainda leva flores pra crush.';
      if (porc >= 25) return 'ğŸ«¥ Stalkeia story e chora no banho com MarÃ­lia MendonÃ§a.';
      return 'ğŸ§  Ainda tem salvaÃ§Ã£o, mas cuidado com as armadilhas do coraÃ§Ã£o.';
    };
    let texto = 'ğŸ’˜ *RANKING GADO ILUDIDO DO GRUPO* ğŸ’˜\n';
    texto += 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n';
    const mentions = [];
    for (const p of sorteados) {
      const porc = Math.floor(Math.random() * 100) + 1;
      const tag = `@${p.id.split('@')[0]}`;
      mentions.push(p.id);
      texto += `ğŸ‘¤ ${tag} â€” *${porc}% GADO*\n_${frasesGado(porc)}_\n\n`;
    }
    await sock.sendMessage(from, {
      image: { url: 'https://i.postimg.cc/J44GrKwk/images-3.jpg' },
      caption: texto.trim(),
      mentions
    }, { quoted: msg });
  } catch (e) {
    console.error('Erro no comando rankgado:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Erro ao gerar o rank gado.',
    }, { quoted: msg });
  }
}

else if (isGroup && msgLower === 'ranklindo') {
  try {
    const groupMetadata = await getGroupMetadataCached(from, sock);
    const participantes = groupMetadata.participants.filter(p => !p.id.includes('g.us'));
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ˜', key: msg.key } });
  } catch {}
    if (participantes.length < 5) {
      await sock.sendMessage(from, { text: 'âŒ O grupo precisa ter pelo menos 5 membros para gerar o rank lindo.' }, { quoted: msg });
      return;
    }
    const sorteados = participantes
      .sort(() => Math.random() - 0.5)
      .slice(0, 5);
    const frasesLindeza = (porc) => {
      if (porc >= 90) return 'ğŸŒŸ TÃ£o lindo que atÃ© o espelho se apaixona.';
      if (porc >= 75) return 'âœ¨ Um charme que derruba forninhos.';
      if (porc >= 50) return 'ğŸ˜ Bonitinhoâ€¦ de longe.';
      if (porc >= 25) return 'ğŸ™‚ Tem dias melhores, mas a autoestima segue firme.';
      return 'ğŸ«£ Quebra atÃ© a cÃ¢mera frontal com esse rostinho.';
    };
    let texto = 'ğŸŒŸ *TOP 5 MAIS LINDOS DO GRUPO* ğŸŒŸ\n';
    texto += 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n';
    const mentions = [];
    for (const p of sorteados) {
      const porc = Math.floor(Math.random() * 100) + 1;
      const tag = `@${p.id.split('@')[0]}`;
      mentions.push(p.id);
      texto += `ğŸ‘¤ ${tag} â€” *${porc}% LINDO*\n_${frasesLindeza(porc)}_\n\n`;
    }
    await sock.sendMessage(from, {
      image: { url: 'https://i.postimg.cc/J4ZMWk0k/3ee22857e7e927bcd89b9ead6f4274b0.jpg' },
      caption: texto.trim(),
      mentions
    }, { quoted: msg });
  } catch (e) {
    console.error('Erro no comando ranklindo:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Erro ao gerar o rank lindo.',
    }, { quoted: msg });
  }
}

else if (isGroup && msgLower === 'rankfeio') {
  try {
    const groupMetadata = await getGroupMetadataCached(from, sock);
    const participantes = groupMetadata.participants.filter(p => !p.id.includes('g.us'));
    
    try {
      await sock.sendMessage(from, { react: { text: 'ğŸ‘¹', key: msg.key } });
    } catch {}

    if (participantes.length < 5) {
      await sock.sendMessage(from, { text: 'âŒ O grupo precisa de pelo menos 5 membros para o ranking da feiura.' }, { quoted: msg });
      return;
    }

    const sorteados = participantes
      .sort(() => Math.random() - 0.5)
      .slice(0, 5);

    const frasesFeiura = (porc) => {
      if (porc >= 90) return 'ğŸ‘º Feio Ã© pouco, isso aÃ­ foi esculpido na raiva!';
      if (porc >= 75) return 'ğŸ§Ÿâ€â™‚ï¸ Parece que caiu da Ã¡rvore da feiura e bateu em todos os galhos.';
      if (porc >= 50) return 'ğŸ˜¬ Um charme... pra espantar assombraÃ§Ã£o.';
      if (porc >= 25) return 'ğŸ¤” Meio esquisito, mas tem quem goste.';
      return 'ğŸ˜‡ Quase bonito... mas o "quase" Ã© eterno.';
    };

    let texto = 'ğŸ’€ *TOP 5 MAIS FEIOS DO GRUPO* ğŸ’€\n';
    texto += 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n';
    const mentions = [];

    for (const p of sorteados) {
      const porc = Math.floor(Math.random() * 100) + 1;
      const tag = `@${p.id.split('@')[0]}`;
      mentions.push(p.id);
      texto += `ğŸ‘¤ ${tag} â€” *${porc}% FEIO*\n_${frasesFeiura(porc)}_\n\n`;
    }

    await sock.sendMessage(from, {
      video: { url: 'https://files.catbox.moe/i4kafb.mp4' },
      caption: texto.trim(),
      mentions
    }, { quoted: msg });

  } catch (e) {
    console.error('Erro no comando rankfeio:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Deu erro ao montar o ranking da feiura.',
    }, { quoted: msg });
  }
}

else if (isGroup && /^dado$/i.test(msgLower)) {
  try {
    // ğŸ§  Captura o usuÃ¡rio alvo de forma robusta
    const context = msg.message?.extendedTextMessage?.contextInfo;
    let rawAlvo = sender;
    if (Array.isArray(context?.mentionedJid) && context.mentionedJid.length > 0) {
      rawAlvo = context.mentionedJid[0];
    } else if (typeof context?.participant === 'string') {
      rawAlvo = context.participant;
    } else if (msg.key.participant) {
      rawAlvo = msg.key.participant;
    }
    const alvo = typeof rawAlvo === 'string' ? rawAlvo : String(rawAlvo);
    const userNumber = alvo.replace(/\D/g, '');
    const userId = `${userNumber}@s.whatsapp.net`;
    const userTag = `@${userNumber}`;
    try {
      await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
    } catch {}
    if (typeof reagir === 'function') {
      setTimeout(() => reagir(from, "ğŸ²", msg), 300);
    }
    const dadoImages = [
      { url: "https://i.ibb.co/zmVD85Z/53025f3f00f8.webp", no: 6 },
      { url: "https://i.ibb.co/BchBsJ1/0b7b4a9b811d.webp", no: 5 },
      { url: "https://i.ibb.co/25Pf1sY/a66d2b63f357.webp", no: 4 },
      { url: "https://i.ibb.co/hccTrhd/5b36dd6442b8.webp", no: 3 },
      { url: "https://i.ibb.co/9tPHPDt/544dbba5bb75.webp", no: 2 },
      { url: "https://i.ibb.co/y040HHw/3e583d6459e6.webp", no: 1 }
    ];
    const resultado = dadoImages[Math.floor(Math.random() * dadoImages.length)];
    await sock.sendMessage(from, {
      text: `ğŸ² Jogando o dado para ${userTag}...`,
      mentions: [userId]
    }, { quoted: msg });
    await new Promise(resolve => setTimeout(resolve, 1000));
    await sock.sendMessage(from, {
      sticker: { url: resultado.url }
    }, { quoted: msg });
    await sock.sendMessage(from, {
      text: `ğŸ² O dado caiu no nÃºmero *${resultado.no}*!`,
      mentions: [userId]
    }, { quoted: msg });
  } catch (e) {
    console.error("Erro ao executar comando dado:", e);
    await sock.sendMessage(from, {
      text: "âŒ Ocorreu um erro ao jogar o dado.",
      mentions: [sender]
    }, { quoted: msg });
  }
}

else if (isGroup && /^([#])?vdddsf\b/i.test(msgLower)) {
  const filePath = './dados/vdddsf.json';
  if (!fs.existsSync(filePath)) {
    await sock.sendMessage(from, { text: 'âŒ Arquivo vdddsf.json nÃ£o encontrado.' }, { quoted: msg });
    return;
  }
  try {
    const perguntas = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
    if (!Array.isArray(perguntas) || perguntas.length === 0) {
      await sock.sendMessage(from, { text: 'âŒ Nenhuma pergunta encontrada no vdddsf.json.' }, { quoted: msg });
      return;
    }
    const perguntaAleatoria = perguntas[Math.floor(Math.random() * perguntas.length)];
    await sock.sendMessage(from, {
      poll: {
        name: `ğŸ§  ${perguntaAleatoria}`,
        values: ['âœ… Sim', 'âŒ NÃ£o'],
        selectableCount: 1
      }
    }, { quoted: msg });

  } catch (e) {
    console.error('Erro ao ler vdddsf.json:', e);
    await sock.sendMessage(from, { text: 'âŒ Erro ao processar o arquivo vdddsf.json.' }, { quoted: msg });
  }
}

else if (isGroup && /\b(pinga|pinguÃ§o|cachaceiro|cachaÃ§a|bÃªbado|bÃªbada|cachaceira|pinguÃ§a)\b/i.test(msgLower)) {
  try {
    if (sock.sendMessage && msg.key) {
      await sock.sendMessage(from, {
        react: {
          text: 'ğŸ»',
          key: msg.key
        }
      });
    }
    const { data } = await axios.get('https://files.catbox.moe/vvgymg.mp3', {
      responseType: 'arraybuffer'
    });
    const audioBuffer = Buffer.from(data, 'binary');
    await sock.sendMessage(from, {
      audio: audioBuffer,
      mimetype: 'audio/mp4',
      ptt: true
    }, { quoted: msg });
    const stickerBuffer = fs.readFileSync('./dados/figurinhas/pinga.webp');
    await sock.sendMessage(from, {
      sticker: stickerBuffer
    }, { quoted: msg });
  } catch (e) {
    console.error("Erro no comando pinga:", e);
    await sock.sendMessage(from, {
      text: 'âŒ Erro ao executar o comando pinga.'
    }, { quoted: msg });
  }
}
//     figu 58
else if (msgLower === 'fs') {
  const quotedContext = msg.message?.extendedTextMessage?.contextInfo;
  const quotedMsg = quotedContext?.quotedMessage;
  const participant = quotedContext?.participant;
  if (!quotedMsg || (!quotedMsg.imageMessage && !quotedMsg.videoMessage)) {
    await sock.sendMessage(from, {
      text: 'â—Responda a uma *imagem* ou *vÃ­deo de atÃ© 9 segundos* com "fs" para criar uma figurinha.',
      quoted: msg
    });
    return;
  }
  const isImage = !!quotedMsg.imageMessage;
  const isVideo = !!quotedMsg.videoMessage;
  const mediaType = isImage ? 'imageMessage' : 'videoMessage';
  const mediaData = quotedMsg[mediaType];
  if (!mediaData || !mediaData.url) {
    await sock.sendMessage(from, {
      text: 'âŒ Esta mÃ­dia nÃ£o estÃ¡ mais disponÃ­vel para download. Envie novamente e tente de novo.',
      quoted: msg
    });
    return;
  }
  try {
    await sock.sendMessage(from, { react: { text: 'ğŸ› ï¸', key: msg.key } });
    await sock.sendMessage(from, { text: '_fazendo figuâœ¨ğŸ˜¸_' }, { quoted: msg });

    const buffer = await downloadMediaMessage(
      { message: { [mediaType]: mediaData } },
      'buffer'
    );
    if (!buffer) {
      await sock.sendMessage(from, {
        text: 'âŒ Falha ao baixar a mÃ­dia.',
        quoted: msg
      });
      return;
    }
    if (isVideo && quotedMsg.videoMessage.seconds > 9) {
      await sock.sendMessage(from, {
        text: 'âŒ O vÃ­deo precisa ter no mÃ¡ximo 9 segundos.',
        quoted: msg
      });
      return;
    }
    const timestamp = Date.now();
    const tempInput = `./temp/${timestamp}.${isImage ? 'jpg' : 'mp4'}`;
    const tempOutput = `./temp/${timestamp}.webp`;
    fs.mkdirSync('./temp', { recursive: true });
    fs.writeFileSync(tempInput, buffer);
    const ffmpegCmd = isImage
  ? `ffmpeg -i ${tempInput} -vf "scale=512:512:force_original_aspect_ratio=decrease,format=rgba,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=0x00000000" -vcodec libwebp -lossless 1 -qscale 75 -preset default -loop 0 -an ${tempOutput}`
  : `ffmpeg -t 9 -i ${tempInput} -vf "scale=512:512:force_original_aspect_ratio=decrease,format=rgba,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=0x00000000,fps=15" -vcodec libwebp -lossless 0 -preset default -loop 0 -an -vsync 0 ${tempOutput}`;
    exec(ffmpegCmd, async (err) => {
      try {
        if (err) {
          console.error('Erro ao converter para webp:', err);
          await sock.sendMessage(from, {
            text: 'âŒ Falha ao criar figurinha.',
            quoted: msg
          });
        } else {
          const stickerBuffer = fs.readFileSync(tempOutput);
          await sock.sendMessage(from, { sticker: stickerBuffer }, { quoted: msg });
        }
      } catch (e) {
        console.error('Erro ao enviar figurinha:', e);
      } finally {
        if (fs.existsSync(tempInput)) fs.unlinkSync(tempInput);
        if (fs.existsSync(tempOutput)) fs.unlinkSync(tempOutput);
      }
    });
  } catch (e) {
    console.error('Erro no comando fs:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Ocorreu um erro ao tentar criar a figurinha.',
      quoted: msg
    });
  }
}

else if (/^([#])?toimg$/i.test(msgLower)) {
  try {
    await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
  } catch {}
  const quoted = msg.message?.extendedTextMessage?.contextInfo?.quotedMessage;
  const isSticker = quoted?.stickerMessage;
  const isImage = quoted?.imageMessage;
  const isVideo = quoted?.videoMessage;
  if (!isSticker && !isImage && !isVideo) {
    await sock.sendMessage(from, { text: 'âŒ Marque uma figurinha, imagem ou vÃ­deo curto.' }, { quoted: msg });
    return;
  }
  let mediaType, mediaContent;
  if (isSticker) {
    mediaType = 'stickerMessage';
    mediaContent = quoted.stickerMessage;
  } else if (isImage) {
    mediaType = 'imageMessage';
    mediaContent = quoted.imageMessage;
  } else {
    mediaType = 'videoMessage';
    mediaContent = quoted.videoMessage;
  }
  try {
    const buffer = await downloadMediaMessage(
      { message: { [mediaType]: mediaContent } },
      'buffer',
      {},
      { reuploadRequest: sock }
    );
    const timestamp = Date.now();
    const inputPath = `./temp/${timestamp}.${isSticker ? 'webp' : isImage ? 'jpg' : 'mp4'}`;
    const outputImg = `./temp/${timestamp}.jpg`;
    const outputMp4 = `./temp/${timestamp}.mp4`;
    fs.mkdirSync('./temp', { recursive: true });
    fs.writeFileSync(inputPath, buffer);
    const isAnimatedSticker = isSticker && mediaContent.isAnimated;
    if (isAnimatedSticker) {
      const cmd = `ffmpeg -i ${inputPath} -vf "fps=15,scale=512:-1:flags=lanczos" -c:v libx264 -pix_fmt yuv420p -movflags +faststart ${outputMp4}`;
      exec(cmd, async (err) => {
        if (err) {
          console.error('Erro ao converter figurinha animada:', err);
          await sock.sendMessage(from, { text: 'âŒ Falha ao converter a figurinha animada em vÃ­deo.' }, { quoted: msg });
        } else {
          const videoBuffer = fs.readFileSync(outputMp4);
          await sock.sendMessage(from, { video: videoBuffer, caption: 'ğŸï¸ Figurinha animada convertida em vÃ­deo.' }, { quoted: msg });
          fs.unlinkSync(inputPath);
          fs.unlinkSync(outputMp4);
        }
      });
    } else {
      const cmd = `ffmpeg -i ${inputPath} -vframes 1 -q:v 3 ${outputImg}`;
      exec(cmd, async (err) => {
        if (err) {
          console.error('Erro ao converter para imagem:', err);
          await sock.sendMessage(from, { text: 'âŒ Falha ao converter para imagem.' }, { quoted: msg });
        } else {
          const imgBuffer = fs.readFileSync(outputImg);
          await sock.sendMessage(from, { image: imgBuffer, caption: '*ConversÃ£o concluÃ­dağŸ˜¸*' }, { quoted: msg });
          fs.unlinkSync(inputPath);
          fs.unlinkSync(outputImg);
        }
      });
    }
  } catch (err) {
    console.error('Erro no processo:', err);
    await sock.sendMessage(from, { text: 'âŒ Erro ao processar a mÃ­dia.' }, { quoted: msg });
  }
}

else if (isGroup && (msgLower === 'marca' || msgLower === 'cita')) {
  if (!isGroupAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
    return;
  }
  const groupMetadata = await getGroupMetadataCached(from, sock);
  const participantes = groupMetadata.participants.map(p => p.id);
  const textoMenÃ§Ãµes = participantes.map((p, i) => `ğŸ”¹ ${i + 1}. @${p.split('@')[0]}`).join('\n');
  const lerMais = String.fromCharCode(8206).repeat(4000);
  let ppUrl;
  try {
    ppUrl = await sock.profilePictureUrl(from, 'image');
  } catch {
    ppUrl = 'https://files.catbox.moe/g3o2dt.gif';
  }
  const thumbnailBuffer = await axios.get(ppUrl, { responseType: 'arraybuffer' }).then(res => res.data);
  await sock.sendMessage(from, {
    text: `ğŸ“¢ğŸ¥³ğğğ‘ğ€ ğˆğğ“ğ„ğ‘ğ€ğ†ğˆğ‘âœ¨ğŸ¥³\n\n${lerMais}\n${textoMenÃ§Ãµes}`,
    mentions: participantes,
    contextInfo: {
      mentionedJid: participantes,
      externalAdReply: {
        title: 'ğ’ğ€ğˆ ğƒğ€ ğŒğğˆğ“ğ€ğŸ˜‚â•',
        body: 'ğŒğ„ğŒğğ‘ğğ’ ğˆğğ€ğ“ğˆğ•ğğ’ ğ•ğ€ğˆ ğƒğ„ ğ…ğŸª¦',
        thumbnail: thumbnailBuffer,
        mediaType: 1,
        showAdAttribution: false,
        sourceUrl: 'https://chat.whatsapp.com/Ezv4hMN3cEi5Eipxz714Ar?mode=ems_copy_t'
      }
    }
  }, { quoted: msg });
}
    
else if (isGroup && /^([#])?linkgp\b/i.test(msgLower)) {
  if (!isGroupAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
    return;
  }
  try {
    const groupMetadata = await sock.groupMetadata(from);
    const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';
    const botIsAdmin = groupMetadata.participants.find(p => p.id === botNumber)?.admin;
    if (!botIsAdmin) {
      await sock.sendMessage(from, { text: 'âš ï¸ Eu preciso ser administrador para obter o link do grupo.' }, { quoted: msg });
      return;
    }
    const inviteCode = await sock.groupInviteCode(from);
    const nomeGrupo = groupMetadata.subject || "Grupo";
    const linkGrupo = `https://chat.whatsapp.com/${inviteCode}`;
    let fotoGrupo;
    try {
      fotoGrupo = await sock.profilePictureUrl(from, 'image');
    } catch {
      fotoGrupo = 'https://linkfly.to/nexosfc';
    }
    await sock.sendMessage(from, {
      text: `*ğŸ”—ğŸ’•Link do grupo* *${nomeGrupo}*:\n${linkGrupo}`,
      contextInfo: {
        externalAdReply: {
          title: `ğŸ”— ${nomeGrupo}`,
          body: 'ğŸŒŸ Clique para entrar no grupo!',
          mediaType: 2,
          thumbnailUrl: fotoGrupo,
          mediaUrl: linkGrupo,
          sourceUrl: linkGrupo,
          showAdAttribution: false
        }
      }
    }, { quoted: msg });
  } catch (error) {
    console.error('Erro ao gerar link do grupo:', error);
    await sock.sendMessage(from, { text: 'âŒ Erro ao obter o link do grupo.' }, { quoted: msg });
  }
}

else if (isGroup && msgLower === 'antitrava') {
  if (!isGroupAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem ativar ou desativar o AntiTrava.' }, { quoted: msg });
    return;
  }
  try {
    await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
  } catch {}
  const configPath = `./dados/grupos/${from}.json`;
  let configGrupo = {};
  if (fs.existsSync(configPath)) {
    configGrupo = JSON.parse(fs.readFileSync(configPath));
  }
  configGrupo.antitrava = !configGrupo.antitrava;
  fs.writeFileSync(configPath, JSON.stringify(configGrupo, null, 2));
  if (configGrupo.antitrava) {
    await sock.sendMessage(from, {
      text: `ğŸ›¡ï¸ Sistema AntiTrava ativado ğŸ–– ğ—”ğ˜ƒğ—¶ğ˜€ğ—² ğ—®ğ—¼ğ˜€ ğ—ºğ—²ğ—ºğ—¯ğ—¿ğ—¼ğ˜€ ğ˜ğ—¼ğ—ºğ—®ğ—¿ ğ—°ğ˜‚ğ—¶ğ—±ğ—®ğ—±ğ—¼ ğ—°ğ—¼ğ—º ğ—ºğ—²ğ—»ğ˜€ğ—®ğ—´ğ—²ğ—»ğ˜€ ğ—ºğ˜‚ğ—¶ğ˜ğ—¼ ğ—¹ğ—¼ğ—»ğ—´ğ—®ğ˜€ğŸ˜¹!`
    }, { quoted: msg });
  } else {
    await sock.sendMessage(from, {
      text: `*antitrava desligado*`
    }, { quoted: msg });
  }
}

else if (isGroup && msgLower === 'nuke') {
  const dono = JSON.parse(fs.readFileSync('./dono/info.json')).numerodono;
  const senderNumero = (msg.key.participant || msg.key.remoteJid).split('@')[0]; // âœ… Seguro
  if (senderNumero !== dono) {
    await sock.sendMessage(from, { text: 'âŒ Apenas o dono pode usar.' }, { quoted: msg });
    return;
  }
  try {
    await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
  } catch {}
  const groupMetadata = await sock.groupMetadata(from);
  const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';
  const membrosParaRemover = groupMetadata.participants
    .map(p => p.id)
    .filter(id => id !== botNumber);
  if (membrosParaRemover.length === 0) {
    await sock.sendMessage(from, { text: 'ğŸ‘¥ Nenhum membro para remover.' }, { quoted: msg });
    return;
  }
  await sock.sendMessage(from, { text: `ğŸ’£ Iniciando remoÃ§Ã£o de ${membrosParaRemover.length} membros...` }, { quoted: msg });
  const bloco = 5;
  for (let i = 0; i < membrosParaRemover.length; i += bloco) {
    const lote = membrosParaRemover.slice(i, i + bloco);
    try {
      await sock.groupParticipantsUpdate(from, lote, 'remove');
      await new Promise(r => setTimeout(r, 1500));
    } catch (e) {
      console.error('Erro ao remover lote:', lote, e);
    }
  }

  await sock.sendMessage(from, { text: 'âœ… ğ—šğ—¿ğ˜‚ğ—½ğ—¼ ğ—¹ğ—¶ğ—ºğ—½ğ—¼ ğŸ––' }, { quoted: msg });
}

else if (msgLower === 'reiniciar') {
try {
    await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
  } catch {}
  const dono = JSON.parse(fs.readFileSync('./dono/info.json')).numerodono;
  const senderID = msg.key.participant || msg.key.remoteJid;
  const senderNum = typeof senderID === 'string' ? senderID.split('@')[0].replace(/\D/g, '') : '';
  if (senderNum !== dono) {
    await sock.sendMessage(from, { text: 'âŒ Apenas o dono pode usar este comando.' }, { quoted: msg });
    return;
  }
  let porcentagem = 0;
  const barra = (porcentagem) => {
    const total = 20;
    const preenchido = Math.round((porcentagem / 100) * total);
    const vazio = total - preenchido;
    return `[${'â–ˆ'.repeat(preenchido)}${'â–‘'.repeat(vazio)}] ${porcentagem}%`;
  };
  const mensagem = await sock.sendMessage(from, { text: ` .....\n${barra(porcentagem)}` }, { quoted: msg });
  const interval = setInterval(async () => {
    porcentagem += 10;
    if (porcentagem > 100) porcentagem = 100;
    await sock.sendMessage(from, {
      text: `*ğŸ’•ğ˜™ğ˜¦ğ˜ªğ˜¯ğ˜ªğ˜¤ğ˜ªğ˜¢ğ˜¯ğ˜¥ğ˜° Sombra bot à¸…â‰½^â€¢â©Šâ€¢^â‰¼à¸…*\n${barra(porcentagem)}`,
      edit: mensagem.key
    });
    if (porcentagem === 100) {
      clearInterval(interval);
      await new Promise(res => setTimeout(res, 1000));
      process.exit(0);
    }
  }, 400);
}

else if (msgLower.startsWith('bloock')) {
  const dono = JSON.parse(fs.readFileSync('./dono/info.json')).numerodono;
  const senderID = msg.key.participant || msg.key.remoteJid;
  const senderNum = typeof senderID === 'string' ? senderID.split('@')[0].replace(/\D/g, '') : '';
  if (senderNum !== dono) {
    await sock.sendMessage(from, { text: 'âŒ Apenas o dono pode usar este comando.' }, { quoted: msg });
    return;
  }
  const textoMsg =
    msg.message?.conversation ||
    msg.message?.extendedTextMessage?.text ||
    msg.message?.imageMessage?.caption ||
    msg.message?.videoMessage?.caption ||
    '';
  const args = textoMsg.trim().split(/\s+/);
  if (args.length < 2) {
    await sock.sendMessage(from, {
      text: 'âŒ Por favor, informe o nÃºmero para bloquear.\nExemplo: bloock 5511999999999',
      quoted: msg
    });
    return;
  }
  const numeroAlvo = args[1].replace(/\D/g, '');
  if (!numeroAlvo || numeroAlvo.length < 10) {
    await sock.sendMessage(from, { text: 'âŒ NÃºmero invÃ¡lido.' }, { quoted: msg });
    return;
  }
  const bloqueados = carregarBloqueados();
  const jidAlvo = numeroAlvo + '@s.whatsapp.net';
  if (bloqueados.includes(jidAlvo)) {
    await sock.sendMessage(from, { text: '*Este nÃºmero jÃ¡ estÃ¡ bloqueado.*' }, { quoted: msg });
    return;
  }
  bloqueados.push(jidAlvo);
  salvarBloqueados(bloqueados);
  await sock.sendMessage(from, {
    text: `*NÃºmero @${numeroAlvo} bloqueado para nÃ£o usar o bot ğŸ¥²*.`,
    mentions: [jidAlvo]
  }, { quoted: msg });
}

else if (msgLower.startsWith('unbloock')) {
  const dono = JSON.parse(fs.readFileSync('./dono/info.json')).numerodono;
  const senderID = msg.key.participant || msg.key.remoteJid;
  const senderNum = typeof senderID === 'string' ? senderID.split('@')[0].replace(/\D/g, '') : '';
  if (senderNum !== dono) {
    await sock.sendMessage(from, { text: 'âŒ Apenas o dono pode usar este comando.' }, { quoted: msg });
    return;
  }
  const textoMsg =
    msg.message?.conversation ||
    msg.message?.extendedTextMessage?.text ||
    msg.message?.imageMessage?.caption ||
    msg.message?.videoMessage?.caption ||
    '';
  const args = textoMsg.trim().split(/\s+/);
  if (args.length < 2) {
    await sock.sendMessage(from, {
      text: 'âŒ Informe o nÃºmero para desbloquear.\nExemplo: unbloock 5511999999999',
      quoted: msg
    });
    return;
  }
  const numeroAlvo = args[1].replace(/\D/g, '');
  if (!numeroAlvo || numeroAlvo.length < 10) {
    await sock.sendMessage(from, { text: 'âŒ NÃºmero invÃ¡lido.' }, { quoted: msg });
    return;
  }
  const jid = numeroAlvo + '@s.whatsapp.net';
  let bloqueados = carregarBloqueados();
  if (!bloqueados.includes(jid)) {
    await sock.sendMessage(from, { text: '*Este nÃºmero nÃ£o estÃ¡ bloqueado.*' }, { quoted: msg });
    return;
  }

  bloqueados = bloqueados.filter(num => num !== jid);
  salvarBloqueados(bloqueados);

  await sock.sendMessage(from, {
    text: `*NÃºmero @${numeroAlvo} desbloqueado com sucesso ğŸ¥³*.`,
    mentions: [jid]
  }, { quoted: msg });
}

else if (msgLower === 'listblock') {
  const dono = JSON.parse(fs.readFileSync('./dono/info.json')).numerodono;
  const senderID = msg.key.participant || msg.key.remoteJid;
  const senderNum = typeof senderID === 'string' ? senderID.split('@')[0].replace(/\D/g, '') : '';

  if (senderNum !== dono) {
    await sock.sendMessage(from, { text: 'âŒ Apenas o dono pode usar este comando.' }, { quoted: msg });
    return;
  }

  const bloqueados = carregarBloqueados();

  if (bloqueados.length === 0) {
    await sock.sendMessage(from, { text: 'Nenhum nÃºmero estÃ¡ bloqueado atualmente.' }, { quoted: msg });
    return;
  }

  const lista = bloqueados.map((jid, i) => `*${i + 1}.* @${jid.replace(/@.*/, '')}`).join('\n');

  await sock.sendMessage(from, {
    text: `ğŸ“› *Lista de nÃºmeros bloqueados:*\n\n${lista}`,
    mentions: bloqueados
  }, { quoted: msg });
}

else if (isGroup && msg.message?.conversation?.toLowerCase().includes('prefixo')) {
  const senderId = msg.key.participant || msg.key.remoteJid;
  if (ignoradosPrefixo[senderId] && Date.now() < ignoradosPrefixo[senderId]) {
    return;
  }
  if (!floodPrefixo[senderId]) floodPrefixo[senderId] = [];
  floodPrefixo[senderId].push(Date.now());
  floodPrefixo[senderId] = floodPrefixo[senderId].filter(ts => Date.now() - ts < 5000);
  if (floodPrefixo[senderId].length >= 3) {
    ignoradosPrefixo[senderId] = Date.now() + 10 * 60 * 1000;
    await sock.sendMessage(from, {
      text: 'Ei! Para de flodar meus circuitos, seu jeca ğŸ˜¡',
    }, { quoted: msg });
    await sock.sendMessage(from, {
      sticker: fs.readFileSync('./dados/figurinhas/flodprefixo.webp')
    }, { quoted: msg });
    return;
  }
  await sock.sendMessage(from, {
    text: 'ğŸ˜‚ *Prefixo? Eu sou modernağŸ‘ï¸ğŸ‘„ğŸ‘ï¸, nÃ£o uso isso mais nÃ£o!*\nSÃ³ digita o comando direto, exemplo: `play Anitta`, `menu`, `ping`',
  }, { quoted: msg });
  await sock.sendMessage(from, {
    sticker: fs.readFileSync('./dados/figurinhas/prefixo.webp')
  }, { quoted: msg });
  try {
    await sock.sendMessage(from, {
      react: { text: 'ğŸ¤­', key: msg.key }
    });
  } catch (e) {
    console.error('Erro ao reagir:', e);
  }
}

else if (msgLower.startsWith('mute')) {
  const dono = JSON.parse(fs.readFileSync('./dono/info.json')).numerodono;
  const senderID = msg.key.participant || msg.key.remoteJid;
  const senderNum = typeof senderID === 'string' ? senderID.split('@')[0].replace(/\D/g, '') : '';
  if (senderNum !== dono) {
    await sock.sendMessage(from, { text: 'âŒ Apenas o dono pode usar este comando.' }, { quoted: msg });
    return;
  }
  const mutedUsers = JSON.parse(fs.readFileSync('./dados/muted.json'));
  if (!mutedUsers[from]) mutedUsers[from] = [];

  const citado = msg.message?.extendedTextMessage?.contextInfo?.participant ||
                 (msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [])[0];
  const textoMsg = msg.message?.conversation ||
                   msg.message?.extendedTextMessage?.text ||
                   msg.message?.imageMessage?.caption ||
                   msg.message?.videoMessage?.caption || '';
  const args = textoMsg.trim().split(/\s+/);
  let alvo;
  if (citado) {
    alvo = citado;
  } else if (args.length >= 2 && args[1].match(/\d{6,}/)) {
    alvo = args[1].replace(/\D/g, '') + '@s.whatsapp.net';
  } else if (msg.message?.extendedTextMessage?.contextInfo?.stanzaId) {
    alvo = msg.message.extendedTextMessage.contextInfo.participant;
  } else {
    await sock.sendMessage(from, {
      text: 'âŒ Use:\n.mute @user\n.mute 5511999999999\n.mute respondendo a mensagem',
      quoted: msg
    });
    return;
  }
  if (mutedUsers[from].includes(alvo)) {
    await sock.sendMessage(from, {
      text: `@${alvo.split('@')[0]} jÃ¡ estÃ¡ mutado.`,
      mentions: [alvo]
    }, { quoted: msg });
    return;
  }
  mutedUsers[from].push(alvo);
  fs.writeFileSync('./dados/muted.json', JSON.stringify(mutedUsers, null, 2));
  await sock.sendMessage(from, {
    text: `ğŸ”‡ @${alvo.split('@')[0]} foi mutado com sucesso.`,
    mentions: [alvo]
  }, { quoted: msg });
}

else if (msgLower.startsWith('desmute')) {
  const dono = JSON.parse(fs.readFileSync('./dono/info.json')).numerodono;
  const senderID = msg.key.participant || msg.key.remoteJid;
  const senderNum = typeof senderID === 'string' ? senderID.split('@')[0].replace(/\D/g, '') : '';
  if (senderNum !== dono) {
    await sock.sendMessage(from, { text: 'âŒ Apenas o dono pode usar este comando.' }, { quoted: msg });
    return;
  }
  const mutedUsers = JSON.parse(fs.readFileSync('./dados/muted.json'));
  if (!mutedUsers[from]) mutedUsers[from] = [];
  const citado = msg.message?.extendedTextMessage?.contextInfo?.participant ||
                 (msg.message?.extendedTextMessage?.contextInfo?.mentionedJid || [])[0];
  const textoMsg = msg.message?.conversation ||
                   msg.message?.extendedTextMessage?.text ||
                   msg.message?.imageMessage?.caption ||
                   msg.message?.videoMessage?.caption || '';
  const args = textoMsg.trim().split(/\s+/);
  let alvo;
  if (citado) {
    alvo = citado;
  } else if (args.length >= 2 && args[1].match(/\d{6,}/)) {
    alvo = args[1].replace(/\D/g, '') + '@s.whatsapp.net';
  } else if (msg.message?.extendedTextMessage?.contextInfo?.stanzaId) {
    alvo = msg.message.extendedTextMessage.contextInfo.participant;
  } else {
    await sock.sendMessage(from, {
      text: 'âŒ Use:\n.desmute @user\n.desmute 5511999999999\n.desmute respondendo a mensagem',
      quoted: msg
    });
    return;
  }
  if (!mutedUsers[from].includes(alvo)) {
    await sock.sendMessage(from, {
      text: `@${alvo.split('@')[0]} nÃ£o estÃ¡ mutado.`,
      mentions: [alvo]
    }, { quoted: msg });
    return;
  }
  mutedUsers[from] = mutedUsers[from].filter(j => j !== alvo);
  fs.writeFileSync('./dados/muted.json', JSON.stringify(mutedUsers, null, 2));
  await sock.sendMessage(from, {
    text: `ğŸ”Š @${alvo.split('@')[0]} foi desmutado com sucesso.`,
    mentions: [alvo]
  }, { quoted: msg });
}

else if (isGroup && msgLower === 'idgp') {
  const donoPath = './dono/info.json';
  if (!fs.existsSync(donoPath)) {
    await sock.sendMessage(from, { text: 'âŒ Arquivo de dono nÃ£o encontrado.' }, { quoted: msg });
    return;
  }
  const numerodono = JSON.parse(fs.readFileSync(donoPath, 'utf-8')).numerodono.replace(/\D/g, '');
  const senderRaw = msg.key.participant || msg.key.remoteJid || sender;
  const numeroSender = String(senderRaw).replace(/\D/g, '');
  if (numeroSender !== numerodono) {
    await sock.sendMessage(from, { text: 'âŒ Apenas o dono pode usar este comando.' }, { quoted: msg });
    return;
  }
  await sock.sendMessage(from, { text: `ğŸ†”\n${from}` }, { quoted: msg });
}

else if (isGroup && msgLower === 'sairgp') {
  const donoPath = './dono/info.json';
  if (!fs.existsSync(donoPath)) {
    await sock.sendMessage(from, { text: 'âŒ Arquivo de dono nÃ£o encontrado.' }, { quoted: msg });
    return;
  }
  const numerodono = JSON.parse(fs.readFileSync(donoPath, 'utf-8')).numerodono.replace(/\D/g, '');
  const senderRaw = msg.key.participant || msg.key.remoteJid || sender;
  const numeroSender = String(senderRaw).replace(/\D/g, '');
  if (numeroSender !== numerodono) {
    await sock.sendMessage(from, { text: 'âŒ Apenas o dono pode usar este comando.' }, { quoted: msg });
    return;
  }
  await sock.sendMessage(from, { text: '_ğŸ‘‹Saindo de cena_' }, { quoted: msg });
  await sock.groupLeave(from);
}

else if (!isGroup && msgLower.startsWith('entrargp')) {
  const donoPath = './dono/info.json';
  if (!fs.existsSync(donoPath)) {
    await sock.sendMessage(from, { text: 'âŒ Arquivo de dono nÃ£o encontrado.' }, { quoted: msg });
    return;
  }
  const numerodono = JSON.parse(fs.readFileSync(donoPath, 'utf-8')).numerodono.replace(/\D/g, '');
  const senderRaw = msg.key.participant || msg.key.remoteJid || sender;
  const numeroSender = String(senderRaw).replace(/\D/g, '');
  if (numeroSender !== numerodono) {
    await sock.sendMessage(from, { text: 'âŒ Apenas o dono pode usar este comando.' }, { quoted: msg });
    return;
  }
  const conteudoMsg = msg.message?.conversation
    || msg.message?.extendedTextMessage?.text
    || '';
  const partes = conteudoMsg.trim().split(/\s+/);
  const linkGrupo = partes[1]?.trim();
  if (!linkGrupo || !linkGrupo.includes('whatsapp.com/')) {
    await sock.sendMessage(from, { text: 'âŒ Link invÃ¡lido. Envie um link como: entrargp https://chat.whatsapp.com/XXXXX' }, { quoted: msg });
    return;
  }
  try {
    const match = linkGrupo.match(/chat\.whatsapp\.com\/([A-Za-z0-9]+)/);
    const inviteCode = match?.[1];
    if (!inviteCode) {
      throw new Error('Invite code nÃ£o encontrado.');
    }
    await sock.groupAcceptInvite(inviteCode);
    await sock.sendMessage(from, { text: '*ğŸ’• Entrei no grupo mestre ğŸ™‡ğŸ»â€â™€ï¸*' }, { quoted: msg });
  } catch (e) {
    console.error('Erro ao entrar no grupo:', e);
    await sock.sendMessage(from, { text: 'âŒ Erro ao tentar entrar no grupo.' }, { quoted: msg });
  }
}

else if (msgLower === 'blockgp') {
  await blockgp(from, msg.key.participant || from, sock);
}

else if (msgLower === 'autovisu') {
  const donoPath = './dono/info.json';
  if (!fs.existsSync(donoPath)) return;

  const numerodono = JSON.parse(fs.readFileSync(donoPath, 'utf-8')).numerodono.replace(/\D/g, '');
  const senderRaw = msg.key.participant || msg.key.remoteJid || sender;
  const numeroSender = String(senderRaw).replace(/\D/g, '');

  if (numeroSender !== numerodono) {
    // ğŸš« NÃƒO responde membros que nÃ£o sÃ£o donos
    return;
  }

  const grupoPath = `./dados/grupos/${from}.json`;
  let configGrupo = fs.existsSync(grupoPath) ? JSON.parse(fs.readFileSync(grupoPath, 'utf-8')) : { autovisu: false };

  configGrupo.autovisu = !configGrupo.autovisu;
  fs.writeFileSync(grupoPath, JSON.stringify(configGrupo, null, 2));

  await sock.sendMessage(from, {
    text: `ğŸ‘ï¸ Auto VisualizaÃ§Ã£o de mensagens ${configGrupo.autovisu ? 'ativada' : 'desativada'}!`
  }, { quoted: msg });
}
else if (
  isGroup &&
  (msgLower === 'gpa' || msgLower === 'gpf' || msgLower.startsWith('gpa ') || msgLower.startsWith('gpf '))
) {
  const tipo = msgLower.startsWith('gpa') ? 'gpa' : 'gpf';
  const partes = msgLower.trim().split(/\s+/);
  const argumento = partes.slice(1).join(' ').trim();

  const groupMetadata = await getSafeGroupMetadata(sock, from);
  const participantes = groupMetadata?.participants || [];
  const senderId = msg.key.participant || msg.key.remoteJid;
  const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';
  const isGroupAdmin = participantes.some(p => p.id === senderId && p.admin);
  const isBotAdmin = participantes.some(p => p.id === botNumber && p.admin);

  if (!isGroupAdmin) {
    await sock.sendMessage(from, {
      text: 'âš ï¸ Apenas *administradores* podem usar esse comando.'
    }, { quoted: msg });
    return;
  }

  if (!isBotAdmin) {
    await sock.sendMessage(from, {
      text: 'ğŸš« *NÃ£o sou admin do grupo.*'
    }, { quoted: msg });
    return;
  }

  if (!argumento) {
    await sock.groupSettingUpdate(from, tipo === 'gpa' ? 'not_announcement' : 'announcement');
    await sock.sendMessage(from, {
      text: tipo === 'gpa' ? '*â˜‘ï¸Grupo aberto*' : '*ğŸš«Grupo fechado*'
    }, { quoted: msg });
    return;
  }

  let h, m;
  const cleanArg = argumento.replace(/\s+/g, '');

  if (/^\d{1,2}:\d{2}$/.test(argumento)) {
    [h, m] = argumento.split(':').map(Number);
  } else if (/^\d{1,2}h\d{1,2}m$/.test(cleanArg)) {
    const match = cleanArg.match(/^(\d{1,2})h(\d{1,2})m$/);
    if (match) {
      h = Number(match[1]);
      m = Number(match[2]);
    }
  }

  if (h === undefined || m === undefined || h > 23 || m > 59) {
    await sock.sendMessage(from, {
      text: 'âŒ Use o formato correto:\nEx: `gpa 22:30` ou `gpf 6h0m`'
    }, { quoted: msg });
    return;
  }

  if (!agendamentos[from]) agendamentos[from] = {};
  agendamentos[from][tipo] = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
  salvarAgendamentos();

  await sock.sendMessage(from, {
    text: `â±ï¸ Agendado para *${agendamentos[from][tipo]}* o comando: *${tipo === 'gpa' ? 'abrir grupo' : 'fechar grupo'}*.`
  }, { quoted: msg });
}

else if (
  isGroup &&
  (msgLower === 'a' || msgLower === 'f')
) {
  const tipo = msgLower === 'a' ? 'abrir' : 'fechar';

  const groupMetadata = await getSafeGroupMetadata(sock, from);
  const participantes = groupMetadata?.participants || [];
  const senderId = msg.key.participant || msg.key.remoteJid;
  const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';
  const isGroupAdmin = participantes.some(p => p.id === senderId && p.admin);
  const isBotAdmin = participantes.some(p => p.id === botNumber && p.admin);

  if (!isGroupAdmin) {
    await sock.sendMessage(from, {
      text: 'âš ï¸ Apenas *administradores* podem usar esse comando.'
    }, { quoted: msg });
    return;
  }

  if (!isBotAdmin) {
    await sock.sendMessage(from, {
      text: 'ğŸš« *NÃ£o sou admin do grupo.*'
    }, { quoted: msg });
    return;
  }

  await sock.groupSettingUpdate(from, tipo === 'abrir' ? 'not_announcement' : 'announcement');
  await sock.sendMessage(from, {
    text: tipo === 'abrir' ? '*â˜‘ï¸ Grupo ABERTO*' : '*ğŸš« Grupo FECHADO*'
  }, { quoted: msg });
}

else if (isGroup && msgLower === 'antiloc') {
  if (!isGroupAdmin) {
    await sleep(1000);
    await sock.sendMessage(from, {
      text: 'âŒ Apenas administradores podem ativar ou desativar o AntiLoc.'
    }, { quoted: msg });
    return;
  }

  try {
    await sock.sendMessage(from, { react: { text: 'ğŸ“', key: msg.key } });
  } catch (e) {}

  const configPath = path.join(__dirname, 'dados', 'grupos', `${from}.json`);
  let configGrupo = {};
  try {
    if (fs.existsSync(configPath)) {
      const raw = fs.readFileSync(configPath);
      configGrupo = JSON.parse(raw);
    }
  } catch (e) {
    console.error('Erro ao ler a config do grupo:', e);
  }

  configGrupo.antiloc = !configGrupo.antiloc;

  try {
    fs.writeFileSync(configPath, JSON.stringify(configGrupo, null, 2));
  } catch (e) {
    console.error('Erro ao salvar config do grupo:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Erro ao salvar a configuraÃ§Ã£o. Tente novamente.'
    }, { quoted: msg });
    return;
  }

  const status = configGrupo.antiloc ? 'ativado' : 'desativado';
  await sock.sendMessage(from, {
    text: `ğŸ“ Sistema AntiLoc ${status}!`
  }, { quoted: msg });
}

else if (msgLower === 'antiporno') {
  const donoPath = './dono/info.json';
  if (!fs.existsSync(donoPath)) {
    await sock.sendMessage(from, { text: 'âŒ Arquivo de dono nÃ£o encontrado.' }, { quoted: msg });
    return;
  }
  const numerodono = JSON.parse(fs.readFileSync(donoPath, 'utf-8')).numerodono.replace(/\D/g, '');
  const senderRaw = msg.key.participant || msg.key.remoteJid || sender;
  const numeroSender = String(senderRaw).replace(/\D/g, '');
  if (numeroSender !== numerodono) {
    await sock.sendMessage(from, { text: 'ğŸš« Apenas o dono do bot pode ativar ou desativar o AntiPornÃ´.' }, { quoted: msg });
    return;
  }
  const config = carregarConfigGrupo(from);
  config.antiporno = !config.antiporno;
  salvarConfigGrupo(from, config);
  await sock.sendMessage(from, {
    text: `ğŸ” AntiPornÃ´ ${config.antiporno ? 'ativado' : 'desativado'} com sucesso!`
  }, { quoted: msg });
}

else if (isGroup && msgLower === 'antilink') {
    if (!isGroupAdmin) {
    await sleep(500);
      await sock.sendMessage(from, {
        text: 'âŒ Apenas administradores podem ativar ou desativar o AntiLink.'
      }, { quoted: msg });
      return;
    }
    try {
      await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
    } catch (e) {}
    const configPath = path.join(__dirname, 'dados', 'grupos', `${from}.json`);
    let configGrupo = {};
    try {
      if (fs.existsSync(configPath)) {
        const raw = fs.readFileSync(configPath);
        configGrupo = JSON.parse(raw);
      }
    } catch (e) {
      console.error('Erro ao ler a config do grupo:', e);
    }
    configGrupo.antilink = !configGrupo.antilink;
    try {
      fs.writeFileSync(configPath, JSON.stringify(configGrupo, null, 2));
    } catch (e) {
      console.error('Erro ao salvar config do grupo:', e);
      await sock.sendMessage(from, {
        text: 'âŒ Erro ao salvar a configuraÃ§Ã£o. Tente novamente.'
      }, { quoted: msg });
      return;
    }

    const status = configGrupo.antilink ? 'ativado' : 'desativado';
    await sock.sendMessage(from, {
      text: `ğŸ”— Sistema AntiLink ${status}!`
    }, { quoted: msg });
  }

else if (isGroup && msgLower === 'antiimg') {
    if (!isGroupAdmin) {
        await sleep(500);
        await sock.sendMessage(from, {
            text: 'âŒ Apenas administradores podem ativar ou desativar o AntiImagem.'
        }, { quoted: msg });
        return;
    }
    try {
        await sock.sendMessage(from, { react: { text: 'â˜‘ï¸', key: msg.key } });
    } catch (e) {}
    const configPath = path.join(__dirname, 'dados', 'grupos', `${from}.json`);
    let configGrupo = {};
    try {
        if (fs.existsSync(configPath)) {
            const raw = fs.readFileSync(configPath);
            configGrupo = JSON.parse(raw);
        }
    } catch (e) {
        console.error('Erro ao ler a config do grupo para antiimagem:', e);
    }
    configGrupo.antiimagem = !configGrupo.antiimagem;
    try {
        fs.writeFileSync(configPath, JSON.stringify(configGrupo, null, 2));
    } catch (e) {
        console.error('Erro ao salvar config do grupo para antiimagem:', e);
        await sock.sendMessage(from, {
            text: 'âŒ Erro ao salvar a configuraÃ§Ã£o. Tente novamente.'
        }, { quoted: msg });
        return;
    }
    const status = configGrupo.antiimagem ? 'ativado' : 'desativado';
    await sock.sendMessage(from, {
        text: `AntiImagem ${status}!`
    }, { quoted: msg });
}
  
else if (isGroup && msgLower === 'antipromote') {
  try {
    const donoRaw = JSON.parse(fs.readFileSync('./dono/info.json', 'utf-8')).numerodono;
    const dono = donoRaw.replace(/\D/g, '');
    const senderRaw = msg.key.participant || msg.key.remoteJid || '';
    const senderSemDDD = String(senderRaw).split('@')[0].replace(/\D/g, '');
    console.log('NÃºmero dono:', dono);
    console.log('NÃºmero sender:', senderSemDDD);
    if (senderSemDDD !== dono) {
      await sock.sendMessage(from, { text: 'âŒ Apenas o dono do bot pode usar este comando.' }, { quoted: msg });
      return;
    }
    const grupoPath = `./dados/grupos/${from}.json`;
    let configGrupo = { antipromote: false };
    if (fs.existsSync(grupoPath)) {
      configGrupo = JSON.parse(fs.readFileSync(grupoPath, 'utf-8'));
    }
    configGrupo.antipromote = !configGrupo.antipromote;
    fs.writeFileSync(grupoPath, JSON.stringify(configGrupo, null, 2));
    const status = configGrupo.antipromote ? 'ativado' : 'desativado';
    await sock.sendMessage(from, { text: `ğŸ›¡ï¸ AntiPromote ${status} com sucesso.` }, { quoted: msg });
  } catch (error) {
    console.error('Erro no comando antipromote:', error);
    await sock.sendMessage(from, { text: 'âŒ Ocorreu um erro ao executar o comando.' }, { quoted: msg });
  }
}

else if (isGroup && /^\.?(ghosts|fantasmas)$/i.test(body)) {
  try {
    carregarContador();
    const metadata = await sock.groupMetadata(from);
    const participantes = metadata.participants || [];
    const fantasmas = [];

    for (const p of participantes) {
      const jid = p.id;
      const totalMsgs = contador[from]?.usuarios?.[jid]?.mensagens || 0;
      if (totalMsgs === 0 || contador[from]?.usuarios?.[jid] === undefined) {
        fantasmas.push(jid);
      }
    }

    if (fantasmas.length === 0) {
      await sock.sendMessage(from, {
        text: 'âœ… Nenhum fantasma encontrado! Todos tÃªm mensagens.'
      }, { quoted: msg });
    } else {
      const lista = fantasmas.map(j => `â€¢ @${j.split('@')[0]}`).join('\n');
      await sock.sendMessage(from, {
        text: `ğŸ‘» *UsuÃ¡rios fantasmas (0 mensagens)*:\n\n${lista}`,
        mentions: fantasmas
      }, { quoted: msg });
    }
  } catch (e) {
    console.error('Erro no comando .ghosts:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Erro ao verificar fantasmas.'
    }, { quoted: msg });
  }
}

else if (msgLower.startsWith('novodono')) {
  if (!donoInfo || !donoInfo.numerodono) {
    await sock.sendMessage(from, { text: 'âŒ O nÃºmero do dono atual nÃ£o estÃ¡ configurado corretamente.' }, { quoted: msg });
    return;
  }
  const numeroDonoAtual = donoInfo.numerodono.replace(/\D/g, '');
  const senderRaw = msg.key.participant || msg.key.remoteJid || sender || '';
  const numeroSender = String(senderRaw).split('@')[0].replace(/\D/g, '');
  const numeroBot = (sock?.user?.id || '').split('@')[0].replace(/\D/g, '');
  const isDono = numeroSender === numeroDonoAtual;
  const isBot = msg.key.fromMe === true;
  if (!isDono && !isBot) {
    await sock.sendMessage(from, {
      text: 'âŒ Apenas o dono atual ou o prÃ³prio bot pode alterar o nÃºmero do dono.'
    }, { quoted: msg });
    return;
  }
  const novoNumero = msgLower.split(' ')[1]?.replace(/\D/g, '');
  if (!novoNumero || novoNumero.length < 10) {
    await sock.sendMessage(from, {
      text: 'âš ï¸ Use: novodono 5511999999999'
    }, { quoted: msg });
    return;
  }
  donoInfo.numerodono = novoNumero;
  fs.writeFileSync('./dono/info.json', JSON.stringify(donoInfo, null, 2));
  await sock.sendMessage(from, {
    text: `âœ… NÃºmero do dono atualizado com sucesso para:\nğŸ“ ${novoNumero}`
  }, { quoted: msg });
}

else if (isGroup && msgLower.startsWith('banghost')) {
  try {
    const donoRaw = JSON.parse(fs.readFileSync('./dono/info.json', 'utf-8')).numerodono;
    const dono = donoRaw.replace(/\D/g, '');
    const senderRaw = msg.key.participant || msg.key.remoteJid || '';
    const senderSemDDD = String(senderRaw).split('@')[0].replace(/\D/g, '');
    
    if (senderSemDDD !== dono) {
      await sock.sendMessage(from, {
        text: 'âŒ Apenas o dono do bot pode usar este comando.'
      }, { quoted: msg });
      return;
    }
    const filePath = './dados/contador.json';
    if (!fs.existsSync(filePath)) {
      await sock.sendMessage(from, {
        text: 'âŒ Nenhum contador encontrado.'
      }, { quoted: msg });
      return;
    }
    const dados = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
    const contadorGrupo = dados[from]?.usuarios || {};
    const metadata = await sock.groupMetadata(from);
    const admins = metadata.participants.filter(p => p.admin !== null).map(p => p.id);
    const jidDono = dono + '@s.whatsapp.net';
    const jidBot = sock.user.id;
    const membrosRemover = metadata.participants.filter(p => {
      if (p.id === jidDono) return false;
      if (p.id === jidBot) return false;
      if (admins.includes(p.id)) return false;     
      const usuarioContador = contadorGrupo[p.id];
      if (!usuarioContador) return true;
      if (typeof usuarioContador.mensagens !== 'number') return true;
      return usuarioContador.mensagens === 0;
    }).map(p => p.id);
    if (membrosRemover.length === 0) {
      await sock.sendMessage(from, {
        text: 'Nenhum membro com 0 mensagens encontrado'
      }, { quoted: msg });
      return;
    }
    const removerEmLotes = async (lista, tamanho = 3) => {
      for (let i = 0; i < lista.length; i += tamanho) {
        const lote = lista.slice(i, i + tamanho);
        try {
          await sock.groupParticipantsUpdate(from, lote, 'remove');
        } catch (e) {
          console.error(`Erro ao remover membros: ${e}`);
        }
        await new Promise(resolve => setTimeout(resolve, 2200));
      }
    };
    await sock.sendMessage(from, {
      text: `ğŸ”ª Removendo ${membrosRemover.length} membro(s) com 0 mensagens ou sem dados...`
    }, { quoted: msg });
    await removerEmLotes(membrosRemover);
    await sock.sendMessage(from, {
      text: 'RemoÃ§Ã£o concluÃ­dağŸ«¡'
    }, { quoted: msg });

  } catch (err) {
    console.error('Erro no comando banghost:', err);
    await sock.sendMessage(from, {
      text: 'âŒ Ocorreu um erro ao executar o comando.'
    }, { quoted: msg });
  }
}

else if (isGroup && /^([#])?(b|ban|kick)\b/i.test(msgLower)) {
  const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';
  const groupMetadata = await getGroupMetadataCached(from, sock);
  const botParticipant = groupMetadata.participants.find(p => p.id === botNumber);
  const botIsAdmin = botParticipant?.admin === 'admin' || botParticipant?.admin === 'superadmin';
  if (!botIsAdmin) {
    await sock.sendMessage(from, { text: 'Eu preciso ser administrador' }, { quoted: msg });
    return;
  }

  const senderId = msg.key.participant || msg.key.remoteJid;
  const senderParticipant = groupMetadata.participants.find(p => p.id === senderId);
  const senderIsAdmin = senderParticipant?.admin === 'admin' || senderParticipant?.admin === 'superadmin';
  if (!senderIsAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar esse comando.' }, { quoted: msg });
    return;
  }

  try {
    await sock.sendMessage(from, { react: { text: 'ğŸ™‡ğŸ»â€â™€ï¸', key: msg.key } });
  } catch {}

  const contextInfo =
    msg.message?.extendedTextMessage?.contextInfo ||
    msg.message?.ephemeralMessage?.message?.extendedTextMessage?.contextInfo ||
    msg.message?.[Object.keys(msg.message)[0]]?.contextInfo ||
    {};

  const mentioned = contextInfo.mentionedJid || [];
  const quotedParticipant = contextInfo.participant || null;
  const quotedMsgSender = contextInfo.stanzaId && contextInfo.remoteJid
    ? contextInfo.participant || contextInfo.remoteJid.split('@')[0] + '@s.whatsapp.net'
    : null;

  const alvos = new Set(mentioned);
  if (quotedParticipant) alvos.add(quotedParticipant);
  if (quotedMsgSender) alvos.add(quotedMsgSender);

  if (alvos.size === 0) {
    await sock.sendMessage(from, {
      text: 'âŒ Marque alguÃ©m com @ ou responda Ã  msg.',
      quoted: msg
    });
    return;
  }

  for (const jid of alvos) {
    if (jid === botNumber) {
      await sock.sendMessage(from, { text: 'coe mane acha q sou burrağŸ™â€â™€ï¸' }, { quoted: msg });
      continue;
    }
    try {
      await sock.groupParticipantsUpdate(from, [jid], 'remove');
      await sock.sendMessage(from, {
        text: `@${jid.split('@')[0]} foi de arasta âš°ï¸`,
        mentions: [jid]
      }, { quoted: msg });
    } catch (e) {
      await sock.sendMessage(from, {
        text: `âŒ Erro ao banir @${jid.split('@')[0]}`,
        mentions: [jid]
      }, { quoted: msg });
    }
  }
}

else if (isGroup && /^([#])?bam\b/i.test(msgLower)) {
  const botNumber = sock.user.id.split(':')[0] + '@s.whatsapp.net';
  const groupMetadata = await getGroupMetadataCached(from, sock);
  const botParticipant = groupMetadata.participants.find(p => p.id === botNumber);
  const botIsAdmin = botParticipant?.admin === 'admin' || botParticipant?.admin === 'superadmin';
  if (!botIsAdmin) {
    await sock.sendMessage(from, { text: 'âš ï¸ Eu preciso ser administrador para remover membros.' }, { quoted: msg });
    return;
  }
  const senderId = msg.key.participant || msg.key.remoteJid;
  const senderParticipant = groupMetadata.participants.find(p => p.id === senderId);
  const senderIsAdmin = senderParticipant?.admin === 'admin' || senderParticipant?.admin === 'superadmin';
  if (!senderIsAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar esse comando.' }, { quoted: msg });
    return;
  }
  const contextInfo =
    msg.message?.extendedTextMessage?.contextInfo ||
    msg.message?.ephemeralMessage?.message?.extendedTextMessage?.contextInfo ||
    msg.message?.[Object.keys(msg.message)[0]]?.contextInfo ||
    {};
  const mentioned = contextInfo.mentionedJid || [];
  const quotedParticipant = contextInfo.participant || null;
  const alvos = new Set(mentioned);
  if (quotedParticipant) alvos.add(quotedParticipant);
  if (alvos.size === 0) {
    await sock.sendMessage(from, {
      text: 'âŒ Marque alguÃ©m com @ ou responda Ã  mensagem da pessoa que deseja banir.',
      quoted: msg
    });
    return;
  }
  for (const jid of alvos) {
    if (jid === botNumber) {
      await sock.sendMessage(from, { text: 'brinca muito kkğŸ§œğŸ»â€â™€ï¸.' }, { quoted: msg });
      continue;
    }
    try {
      await sock.groupParticipantsUpdate(from, [jid], 'remove');
      await sock.sendMessage(from, {
        text: `@${jid.split('@')[0]} foi banido(a) âš°ï¸ğŸ’¤`,
        mentions: [jid]
      }, { quoted: msg });
    } catch (e) {
      await sock.sendMessage(from, {
        text: `âŒ Erro ao banir @${jid.split('@')[0]}`,
        mentions: [jid]
      }, { quoted: msg });
    }
  }
}

else if (isGroup && msgLower === 'antifake') {
  let nomeGrupo = '';
  try {
    const grupoInfo = await sock.groupMetadata(from);
    nomeGrupo = grupoInfo.subject || '';
  } catch (e) {
    console.error('Erro ao obter nome do grupo no comando antifake:', e);
  }
  const configPath = path.join(__dirname, 'dados', 'grupos', `${from}.json`);
  let configGrupo = {};
  try {
    if (fs.existsSync(configPath)) {
      const raw = fs.readFileSync(configPath);
      configGrupo = JSON.parse(raw);
    } else {
      configGrupo = { nome: nomeGrupo };
    }
  } catch (e) {
    console.error('Erro ao ler config do grupo:', e);
    configGrupo = { nome: nomeGrupo };
  }
  let dono = '';
  try {
    dono = JSON.parse(fs.readFileSync('./dono/info.json')).numerodono;
  } catch (e) {
    console.error('Erro ao ler info.json do dono:', e);
  }
  const senderSemDDD = String(sender).split('@')[0].replace(/\D/g, '');
  if (!isGroupAdmin && senderSemDDD !== dono) {
    await sock.sendMessage(from, {
      text: 'âŒ Apenas administradores ou o dono podem usar este comando.'
    }, { quoted: msg });
    return;
  }
  configGrupo.antifake = !configGrupo.antifake;
  try {
    fs.writeFileSync(configPath, JSON.stringify(configGrupo, null, 2));
  } catch (e) {
    console.error('Erro ao salvar config do grupo:', e);
    await sock.sendMessage(from, {
      text: 'âŒ Erro ao salvar a configuraÃ§Ã£o.'
    }, { quoted: msg });
    return;
  }
  const status = configGrupo.antifake ? 'ativado' : 'desativado';
  await sock.sendMessage(from, {
    text: `ğŸ•µï¸ Sistema *AntiFake* ${status}!`
  }, { quoted: msg });
}

else if (
  /^calcular\s+[0-9+\-*/Ã—().\s]+$/i.test(body) &&
  /[+\-*/Ã—]/.test(body) // Garante que tenha pelo menos um operador
) {
  try {
    // Pega sÃ³ a parte depois da palavra "calcular"
    let expressao = body.replace(/^calcular\s+/i, '').trim();

    // Substitui sÃ­mbolo de multiplicaÃ§Ã£o Ã— por *
    expressao = expressao.replace(/Ã—/g, '*').replace(/x/gi, '*');

    const resultado = eval(expressao);
    const operadores = expressao.match(/[+\-*/]/g) || [];
    const dificuldade = operadores.length + expressao.length / 10;
    let frase = '';
    
    if (dificuldade > 20) {
      frase = 'ğŸ˜µâ€ğŸ’« Que complexidade, quase tive que chamar reforÃ§os! ğŸ”¥';
    } else if (dificuldade > 15) {
      frase = 'ğŸ˜… Isso aqui foi missÃ£o impossÃ­vel, mas venci! ğŸ’ª';
    } else if (dificuldade > 10) {
      frase = 'ğŸ˜¹ Caramba, essa foi braba! Quase que eu quebrei a cabeÃ§a!';
    } else if (dificuldade > 7) {
      frase = 'ğŸ¤” Essa deu um trabalho, mas consegui! ğŸ§ ';
    } else if (dificuldade > 4) {
      frase = 'ğŸ˜ FÃ¡cil, moleza! Pode mandar mais! ğŸ˜';
    } else if (dificuldade > 1) {
      frase = 'ğŸ˜‰ Tranquilo, na boa! Pode continuar! ğŸ‰';
    } else {
      frase = 'ğŸ˜Œ Facin facin, manda mais! ğŸ˜‰';
    }

    await sock.sendMessage(from, {
      text: `Resultado:\n${expressao} = *${resultado}*\n\n${frase}`
    }, { quoted: msg });

  } catch (e) {
    console.error('Erro ao calcular expressÃ£o:', e);
    await sock.sendMessage(from, { text: 'âŒ NÃ£o consegui calcular essa conta.' }, { quoted: msg });
  }
  return;
}

 else if (isGroup && msgLower.startsWith('bemvindo')) {
  if (!isGroupAdmin) {
    await sock.sendMessage(from, { text: 'âŒ Apenas administradores podem usar este comando.' }, { quoted: msg });
    return;
  }

  let nomeGrupo = '';
  try {
    const grupoInfo = await sock.groupMetadata(from);
    nomeGrupo = grupoInfo.subject || '';
  } catch (e) {
    console.error('Erro ao obter nome do grupo no comando bemvindo:', e);
  }

  const configGrupo = carregarConfigGrupo(from, nomeGrupo);

  configGrupo.bemvindo = !configGrupo.bemvindo;
  salvarConfigGrupo(from, configGrupo);
  await sock.sendMessage(
    from,
    { text: `ğ—•ğ—¼ğ—®ğ˜€-ğ˜ƒğ—¶ğ—»ğ—±ğ—®ğ˜€ ${configGrupo.bemvindo ? 'ativado' : 'desativado'} \nCaso queira personalizar digite legendabv!` },
    { quoted: msg }
  );
} else if (isGroup && msgLower.startsWith('legendabv')) {
  if (!isGroupAdmin) {
    await sock.sendMessage(from, {
      text: 'âŒ Apenas administradores podem usar este comando.'
    }, { quoted: msg });
    return;
  }

  let nomeGrupo = '';
  try {
    const grupoInfo = await sock.groupMetadata(from);
    nomeGrupo = grupoInfo.subject || '';
  } catch (e) {
    console.error('Erro ao obter nome do grupo no comando legendabv:', e);
  }

  const configGrupo = carregarConfigGrupo(from, nomeGrupo);

  const novoTexto = text.slice('legendabv'.length).trim();
  if (novoTexto.length < 5) {
    await sock.sendMessage(from, {
      text: 'Use legendabv oi #ğ—ºğ—²ğ—ºğ—¯ğ—¿ğ—¼# seja bem vindo(a) ao #ğ—´ğ—¿ğ˜‚ğ—½ğ—¼#\n \n#ğ—ºğ—²ğ—ºğ—¯ğ—¿ğ—¼# serve para marcar o usuario\n \n#ğ—´ğ—¿ğ˜‚ğ—½ğ—¼# serve para exibir o nome do grupo\n \nâŒ Por favor, envie uma mensagem de boas-vindas com pelo menos 5 caracteres.\n _Isso tudo Ã© opcional, personalize do jeito que quiser, boa sorteğŸ’š_'
    }, { quoted: msg });
    return;
  }
  configGrupo.legendabv = novoTexto;
  salvarConfigGrupo(from, configGrupo);
  await sock.sendMessage(from, {
    text: 'âœ…ğ— ğ—²ğ—»ğ˜€ğ—®ğ—´ğ—²ğ—º ğ—±ğ—² ğ—¯ğ—¼ğ—®ğ˜€-ğ˜ƒğ—¶ğ—»ğ—±ğ—®ğ˜€ ğ—®ğ˜ğ˜‚ğ—®ğ—¹ğ—¶ğ˜‡ğ—®ğ—±ğ—®!'
  }, { quoted: msg });
 }
}

module.exports = {
  executarComandos,
  carregarConfigGrupo,
  cmdVIP,
  saveCmdVIP,
  reloadCmdVIP,
  salvarConfigGrupo
};